{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 0854c734ec03107ca2f3","webpack:///./src/rekapi.js","webpack:///external \"lodash\"","webpack:///external \"shifty\"","webpack:///./src/actor.js","webpack:///./src/keyframe-property.js","webpack:///./src/renderers/canvas.js","webpack:///./src/renderers/dom.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/main.js"],"names":["UPDATE_TIME","DEFAULT_EASING","fireEvent","rekapi","eventName","data","_events","forEach","handler","invalidateAnimationLength","_animationLengthValid","determineCurrentLoopIteration","timeSinceStart","animationLength","getAnimationLength","Math","floor","calculateTimeSinceStart","now","_loopTimestamp","isAnimationComplete","currentLoopIteration","_timesToIterate","updatePlayState","stop","calculateLoopPosition","forMillisecond","updateToMillisecond","currentIteration","loopPosition","_loopPosition","keyframeResetList","_latestIteration","lookupObject","name","_actors","fnKeyframes","where","actor","_keyframeProperties","lastFnKeyframe","last","hasFired","invoke","concat","update","each","fnKeyframe","updateToCurrentMillisecond","tick","_loopId","_scheduleUpdate","call","global","_updateFn","setTimeout","getUpdateMethod","requestAnimationFrame","webkitRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","mozCancelRequestAnimationFrame","mozRequestAnimationFrame","getCancelMethod","cancelAnimationFrame","webkitCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","clearTimeout","cancelLoop","_cancelUpdate","STOPPED","PAUSED","PLAYING","rendererBootstrappers","Rekapi","context","_playState","sort","animationComplete","playStateChange","play","pause","beforeUpdate","afterUpdate","addActor","removeActor","beforeAddKeyframeProperty","addKeyframeProperty","removeKeyframeProperty","removeKeyframePropertyComplete","beforeRemoveKeyframeProperty","addKeyframePropertyTrack","removeKeyframePropertyTrack","timelineModified","animationLooped","_animationLength","_pausedAtTime","_lastUpdatedMillisecond","renderers","map","renderer","filter","_","rekapiActor","contains","push","setup","actorId","id","slice","length","without","teardown","getAllActors","iterations","millisecond","_resetFnKeyframesFromMillisecond","playFrom","doResetLaterFnKeyframes","renderOrder","sortBy","_updateState","wasActive","render","get","max","apply","getEnd","exportData","duration","actors","exportTimeline","curves","chain","formulas","formula","x1","curve","displayName","pick","value","rekapiData","curveName","y1","x2","y2","importTimeline","actorData","Object","keys","rendererConstructor","position","splice","getMillisecond","obj","fire","event","getPropertyCacheEntryForMillisecond","_timelinePropertyCache","index","sortedIndex","_millisecond","insertionPointInTrack","track","getLatestProperties","latestProperties","_propertyTracks","propertyTrack","propertyName","propertyIndexInTrack","invalidateCache","_timelinePropertyCacheValid","ensurePropertyCacheValid","_timelineFunctionCache","props","values","a","b","curCacheEntry","property","clone","removeEmptyPropertyTracks","trackName","sortPropertyTracks","keyframeProperty","i","linkToNext","cleanupAfterKeyframeModification","Actor","config","assign","uniqueId","state","easing","Function","undefined","propertyTracks","some","hasOwnProperty","getKeyframeProperty","copyFrom","copyTo","sourcePositions","sourceEasings","keyframe","from","to","hasKeyframeAt","oldIndex","modifyWith","_deleteKeyframePropertyAt","detach","removeKeyframe","newProperties","Error","starts","firstKeyframeProperty","min","endingTracks","tracksToInspect","getStart","until","end","latestProps","serializedProps","serializedEasings","latestProp","propName","modifyKeyframe","newMillisecond","targetMillisecond","_warnOnOutOfOrderKeyframes","console","warn","_insertKeyframePropertyAt","isActive","hasActiveTrack","_active","activeProperty","resetLaterFnKeyframes","start","interpolatedObject","propertyCacheEntry","omit","getValueAt","shouldInvokeForMillisecond","_beforeKeyframePropertyInterpolate","_afterKeyframePropertyInterpolate","set","cache","trackNames","getTrackNames","exportPropertyData","prototype","KeyframeProperty","nextProperty","boundedMillisecond","delta","interpolatePosition","drift","returnValue","dimension","canvas","heightOrWidth","newSize","style","CanvasRenderer","canvasContext","on","clear","height","width","clearRect","CanvasRenderingContext2D","vendorTransforms","transformFunctions","DEFAULT_FPS","TRANSFORM_TOKEN","VENDOR_TOKEN","R_TRANSFORM_TOKEN","RegExp","R_VENDOR_TOKEN","VENDOR_PREFIXES","microsoft","mozilla","opera","w3","webkit","BEZIERS","linear","easeInQuad","easeInCubic","easeInQuart","easeInQuint","easeInSine","easeInExpo","easeInCirc","easeOutQuad","easeOutCubic","easeOutQuart","easeOutQuint","easeOutSine","easeOutExpo","easeOutCirc","easeInOutQuad","easeInOutCubic","easeInOutQuart","easeInOutQuint","easeInOutSine","easeInOutExpo","easeInOutCirc","INJECTED_STYLE_REMOVAL_BUFFER_MS","R_3D_RULE","_3D_RULE","_3D_TOKEN","isInt","number","vendorPrefix","document","body","getActorClassName","forceStyleReset","dummyDiv","createElement","nodeType","parentElement","replaceChild","styleID","injectStyle","css","innerHTML","head","appendChild","setStyle","element","styleName","styleValue","isTransformFunction","buildTransformValue","orderedTransforms","transformProperties","transformComponents","functionName","join","setTransformStyles","transformValue","prefixedTransform","actorRender","propertyNames","transformFunctionNames","otherProperties","reject","_transformOrder","transform","actorTeardown","classList","className","match","sanitizedClassList","replace","onAddActor","bind","applyVendorPropertyPrefixes","keyframes","vendor","applyVendorBoilerplates","toKeyframes","animName","vendors","generateOptimizedKeyframeSegment","fromPercent","toPercent","toFixed","bezier","split","combineTranfromProperties","propsToSerialize","transformNames","isEmpty","reduce","combinedProperties","transformFunction","has","serializeActorStep","targetProp","val","key","generateActorTrackSegment","increments","incrementSize","actorStart","fromProp","accumulator","getLength","percent","step","generateCombinedActorKeyframes","steps","simulateLeadingWait","firstProp","simulateTrailingWait","actorEnd","lastProp","calculateStepPercent","actorLength","generateActorTrackWaitSegment","toProp","isSegmentAWait","canOptimizeKeyframeProperty","every","easings","generateActorKeyframes","leadingWait","previousSegmentWasOptimized","prop","trackSegment","shift","trailingWait","generateBoilerplatedKeyframes","doCombineProperties","generateAnimationNameProperty","animationName","prefix","renderedName","trackNamesToPrint","intersection","difference","generateAnimationIterationProperty","generateCSSAnimationProperties","isCentered","generatedProperties","generateCSSClass","canOptimizeAnyKeyframeProperties","any","getActorCSS","options","getActorCount","ceil","fps","DOMRenderer","_playTimestamp","_cachedCSS","_styleElement","_stopSetTimeoutHandle","isPlaying","prerender","arguments","goToEnd","removeChild","getCss","unrecognizedTransforms","uniq","animationCSS","g","eval","e","window","module","exports"],"mappings":"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","file":"rekapi.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"), require(\"shifty\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"rekapi\", [\"lodash\", \"shifty\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"rekapi\"] = factory(require(\"lodash\"), require(\"shifty\"));\n\telse\n\t\troot[\"rekapi\"] = factory(root[\"lodash\"], root[\"shifty\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/assets/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0854c734ec03107ca2f3","import _ from 'lodash';\nimport { Tweenable, setBezierFunction } from 'shifty';\nimport { Actor } from './actor';\n\nconst UPDATE_TIME = 1000 / 60;\n\nexport const DEFAULT_EASING = 'linear';\n\n/*!\n * Fire an event bound to a Rekapi.\n * @param {Rekapi} rekapi\n * @param {string} eventName\n * @param {Object} [data={}] Optional event-specific data\n */\nexport const fireEvent = (rekapi, eventName, data = {}) =>\n  rekapi._events[eventName].forEach(handler => handler(rekapi, data));\n\n/*!\n * @param {Rekapi} rekapi\n */\nexport const invalidateAnimationLength = rekapi =>\n  rekapi._animationLengthValid = false;\n\n/*!\n * Determines which iteration of the loop the animation is currently in.\n * @param {Rekapi} rekapi\n * @param {number} timeSinceStart\n */\nexport const determineCurrentLoopIteration = (rekapi, timeSinceStart) => {\n  const animationLength = rekapi.getAnimationLength();\n\n  if (animationLength === 0) {\n    return timeSinceStart;\n  }\n\n  return Math.floor(timeSinceStart / animationLength);\n};\n\n/*!\n * Calculate how many milliseconds since the animation began.\n * @param {Rekapi} rekapi\n * @return {number}\n */\nexport const calculateTimeSinceStart = rekapi =>\n  Tweenable.now() - rekapi._loopTimestamp;\n\n/*!\n * Determines if the animation is complete or not.\n * @param {Rekapi} rekapi\n * @param {number} currentLoopIteration\n * @return {boolean}\n */\nexport const isAnimationComplete = (rekapi, currentLoopIteration) =>\n  currentLoopIteration >= rekapi._timesToIterate\n    && rekapi._timesToIterate !== -1;\n\n/*!\n * Stops the animation if it is complete.\n * @param {Rekapi} rekapi\n * @param {number} currentLoopIteration\n */\nexport const updatePlayState = (rekapi, currentLoopIteration) => {\n  if (isAnimationComplete(rekapi, currentLoopIteration)) {\n    rekapi.stop();\n    fireEvent(rekapi, 'animationComplete');\n  }\n};\n\n/*!\n * Calculate how far in the animation loop `rekapi` is, in milliseconds,\n * based on the current time.  Also overflows into a new loop if necessary.\n * @param {Rekapi} rekapi\n * @param {number} forMillisecond\n * @param {number} currentLoopIteration\n * @return {number}\n */\nexport const calculateLoopPosition = (rekapi, forMillisecond, currentLoopIteration) => {\n  const animationLength = rekapi.getAnimationLength();\n\n  return animationLength === 0 ?\n    0 :\n    isAnimationComplete(rekapi, currentLoopIteration) ?\n      animationLength :\n      forMillisecond % animationLength;\n};\n\n/*!\n * Calculate the timeline position and state for a given millisecond.\n * Updates the `rekapi` state internally and accounts for how many loop\n * iterations the animation runs for.\n * @param {Rekapi} rekapi\n * @param {number} forMillisecond\n */\nexport const updateToMillisecond = (rekapi, forMillisecond) => {\n  const currentIteration = determineCurrentLoopIteration(rekapi, forMillisecond);\n  const loopPosition = calculateLoopPosition(\n    rekapi, forMillisecond, currentIteration\n  );\n\n  rekapi._loopPosition = loopPosition;\n\n  let keyframeResetList = [];\n\n  if (currentIteration > rekapi._latestIteration) {\n    fireEvent(rekapi, 'animationLooped');\n\n    // Reset function keyframes\n    const lookupObject = { name: 'function' };\n\n    rekapi._actors.forEach(actor => {\n      const fnKeyframes = _.where(actor._keyframeProperties, lookupObject);\n      const lastFnKeyframe = _.last(fnKeyframes);\n\n      if (lastFnKeyframe && !lastFnKeyframe.hasFired) {\n        lastFnKeyframe.invoke();\n      }\n\n      keyframeResetList = keyframeResetList.concat(fnKeyframes);\n    });\n  }\n\n  rekapi._latestIteration = currentIteration;\n  rekapi.update(loopPosition, true);\n  updatePlayState(rekapi, currentIteration);\n\n  _.each(keyframeResetList, fnKeyframe => {\n    fnKeyframe.hasFired = false;\n  });\n};\n\n/*!\n * Calculate how far into the animation loop `rekapi` is, in milliseconds,\n * and update based on that time.\n * @param {Rekapi} rekapi\n */\nexport const updateToCurrentMillisecond = rekapi =>\n  updateToMillisecond(rekapi, calculateTimeSinceStart(rekapi));\n\n/*!\n * This is the heartbeat of an animation.  This updates `rekapi`'s state and\n * then calls itself continuously.\n * @param {Rekapi} rekapi\n */\nconst tick = rekapi =>\n  // Need to check for .call presence to get around an IE limitation.  See\n  // annotation for cancelLoop for more info.\n  rekapi._loopId = rekapi._scheduleUpdate.call ?\n    rekapi._scheduleUpdate.call(global, rekapi._updateFn, UPDATE_TIME) :\n    setTimeout(rekapi._updateFn, UPDATE_TIME);\n\n/*!\n * @return {Function}\n */\nconst getUpdateMethod = () =>\n  // requestAnimationFrame() shim by Paul Irish (modified for Rekapi)\n  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n  global.requestAnimationFrame       ||\n  global.webkitRequestAnimationFrame ||\n  global.oRequestAnimationFrame      ||\n  global.msRequestAnimationFrame     ||\n  (global.mozCancelRequestAnimationFrame && global.mozRequestAnimationFrame) ||\n  global.setTimeout;\n\n/*!\n * @return {Function}\n */\nconst getCancelMethod = () =>\n  global.cancelAnimationFrame           ||\n  global.webkitCancelAnimationFrame     ||\n  global.oCancelAnimationFrame          ||\n  global.msCancelAnimationFrame         ||\n  global.mozCancelRequestAnimationFrame ||\n  global.clearTimeout;\n\n/*!\n * Cancels an update loop.  This abstraction is needed to get around the fact\n * that in IE, clearTimeout is not technically a function\n * (https://twitter.com/kitcambridge/status/206655060342603777) and thus\n * Function.prototype.call cannot be used upon it.\n * @param {Rekapi} rekapi\n */\nconst cancelLoop = rekapi =>\n  rekapi._cancelUpdate.call ?\n    rekapi._cancelUpdate.call(global, rekapi._loopId) :\n    clearTimeout(rekapi._loopId);\n\nconst STOPPED = 'stopped';\nconst PAUSED = 'paused';\nconst PLAYING = 'playing';\n\n/*!\n * @type {Object.<function>} Contains the context init function to be called in\n * the Rekapi constructor.  This array is populated by modules in the\n * renderers/ directory.\n */\nexport const rendererBootstrappers = [];\n\n/**\n * If this is a rendered animation, the appropriate renderer is accessible as\n * `this.renderer`.  If provided, a reference to `context` is accessible\n * as `this.context`.\n * @param {(Object|CanvasRenderingContext2D|HTMLElement)} [context={}] Sets\n * {@link rekapi.Rekapi#context}. This determines how to render the animation.\n * {@link rekapi.Rekapi} will also automatically set up all necessary {@link\n * rekapi.Rekapi#renderers} based on this value:\n *\n * * If this is not provided or is a plain object (`{}`), the animation will\n * not render anything and {@link rekapi.Rekapi#renderers} will be empty.\n * * If this is a\n * [`CanvasRenderingContext2D`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D),\n * {@link rekapi.Rekapi#renderers} will contain a {@link\n * rekapi.CanvasRenderer}.\n * * If this is a DOM element, {@link rekapi.Rekapi#renderers} will contain a\n * {@link rekapi.DOMRenderer}.\n * @constructs rekapi.Rekapi\n */\nexport class Rekapi {\n  constructor (context = {}) {\n    /**\n     * @member {(Object|CanvasRenderingContext2D|HTMLElement)}\n     * rekapi.Rekapi#context The rendering context for an animation.\n     * @default {}\n     */\n    this.context = context;\n    this._actors = [];\n    this._playState = STOPPED;\n\n    /**\n     * @member {(rekapi.actorSortFunction|null)} rekapi.Rekapi#sort Optional\n     * function for sorting the render order of {@link rekapi.Actor}s.  If set,\n     * this is called each frame before the {@link rekapi.Actor}s are rendered.\n     * If not set, {@link rekapi.Actor}s will render in the order they were\n     * added via {@link rekapi.Rekapi#addActor}.\n     *\n     * The following example assumes that all {@link rekapi.Actor}s are circles\n     * that have a `radius` {@link rekapi.KeyframeProperty}.  The circles will\n     * be rendered in order of the value of their `radius`, from smallest to\n     * largest.  This has the effect of layering larger circles on top of\n     * smaller circles, thus giving a sense of perspective.\n     *\n     *     const rekapi = new Rekapi();\n     *     rekapi.sort = actor => actor.get().radius;\n     * @default null\n     */\n    this.sort = null;\n\n    this._events = {\n      animationComplete: [],\n      playStateChange: [],\n      play: [],\n      pause: [],\n      stop: [],\n      beforeUpdate: [],\n      afterUpdate: [],\n      addActor: [],\n      removeActor: [],\n      beforeAddKeyframeProperty: [],\n      addKeyframeProperty: [],\n      removeKeyframeProperty: [],\n      removeKeyframePropertyComplete: [],\n      beforeRemoveKeyframeProperty: [],\n      addKeyframePropertyTrack: [],\n      removeKeyframePropertyTrack: [],\n      timelineModified: [],\n      animationLooped: []\n    };\n\n    // How many times to loop the animation before stopping\n    this._timesToIterate = -1;\n\n    // Millisecond duration of the animation\n    this._animationLength = 0;\n    this._animationLengthValid = false;\n\n    // The setTimeout ID of `tick`\n    this._loopId = null;\n\n    // The UNIX time at which the animation loop started\n    this._loopTimestamp = null;\n\n    // Used for maintaining position when the animation is paused\n    this._pausedAtTime = null;\n\n    // The last millisecond position that was updated\n    this._lastUpdatedMillisecond = 0;\n\n    // The most recent loop iteration a frame was calculated for\n    this._latestIteration = 0;\n\n    // The most recent millisecond position within the loop that the animation\n    // was updated to\n    this._loopPosition = null;\n\n    this._scheduleUpdate = getUpdateMethod();\n    this._cancelUpdate = getCancelMethod();\n\n    this._updateFn = () => {\n      tick(this);\n      updateToCurrentMillisecond(this);\n    };\n\n    /**\n     * @member {Array.<rekapi.renderer>} rekapi.Rekapi#renderers Instances of\n     * {@link rekapi.renderer} classes, as inferred by the `context`\n     * parameter provided to the {@link rekapi.Rekapi} constructor.  You can\n     * add more renderers to this list manually; see the {@tutorial\n     * multiple-renderers} tutorial for an example.\n     */\n    this.renderers = rendererBootstrappers\n      .map(renderer => renderer(this))\n      .filter(_ => _);\n  }\n\n  /**\n   * Add a {@link rekapi.Actor} to the animation.  Decorates the added {@link\n   * rekapi.Actor} with a reference to this {@link rekapi.Rekapi} instance as\n   * {@link rekapi.Actor#rekapi}.\n   *\n   * @method rekapi.Rekapi#addActor\n   * @param {(rekapi.Actor|Object)} [actor={}] If this is an `Object`, it is used to as\n   * the constructor parameters for a new {@link rekapi.Actor} instance that\n   * is created by this method.\n   * @return {rekapi.Actor} The {@link rekapi.Actor} that was added.\n   */\n  addActor (actor = {}) {\n    const rekapiActor = actor instanceof Actor ?\n      actor :\n      new Actor(actor);\n\n    // You can't add an actor more than once.\n    if (_.contains(this._actors, rekapiActor)) {\n      return rekapiActor;\n    }\n\n    rekapiActor.context = rekapiActor.context || this.context;\n    rekapiActor.rekapi = this;\n\n    // Store a reference to the actor internally\n    this._actors.push(rekapiActor);\n\n    invalidateAnimationLength(this);\n    rekapiActor.setup();\n\n    fireEvent(this, 'addActor', rekapiActor);\n\n    return rekapiActor;\n  }\n\n  /**\n   * @method rekapi.Rekapi#getActor\n   * @param {number} actorId\n   * @return {rekapi.Actor} A reference to an actor from the animation by its\n   * `id`.  You can use {@link rekapi.Rekapi#getActorIds} to get a list of IDs\n   * for all actors in the animation.\n   */\n  getActor (actorId) {\n    return this._actors.filter(actor => actor.id === actorId)[0];\n  }\n\n  /**\n   * @method rekapi.Rekapi#getActorIds\n   * @return {Array.<number>} The `id`s of all {@link rekapi.Actor}`s in the\n   * animation.\n   */\n  getActorIds () {\n    return this._actors.map(actor => actor.id);\n  }\n\n  /**\n   * @method rekapi.Rekapi#getAllActors\n   * @return {Array.<rekapi.Actor>} All {@link rekapi.Actor}s in the animation.\n   */\n  getAllActors () {\n    return this._actors.slice();\n  }\n\n  /**\n   * @method rekapi.Rekapi#getActorCount\n   * @return {number} The number of {@link rekapi.Actor}s in the animation.\n   */\n  getActorCount () {\n    return this._actors.length;\n  }\n\n  /**\n   * Remove an actor from the animation.  This does not destroy the actor, it\n   * only removes the link between it and this {@link rekapi.Rekapi} instance.\n   * This method calls the actor's {@link rekapi.Actor#teardown} method, if\n   * defined.\n   * @method rekapi.Rekapi#removeActor\n   * @param {rekapi.Actor} actor\n   * @return {rekapi.Actor} The {@link rekapi.Actor} that was removed.\n   */\n  removeActor (actor) {\n    // Remove the link between Rekapi and actor\n    this._actors = _.without(this._actors, actor);\n    delete actor.rekapi;\n\n    actor.teardown();\n    invalidateAnimationLength(this);\n\n    fireEvent(this, 'removeActor', actor);\n\n    return actor;\n  }\n\n  /**\n   * Remove all {@link rekapi.Actor}s from the animation.\n   * @method rekapi.Rekapi#removeAllActors\n   * @return {Array.<rekapi.Actor>} The {@link rekapi.Actor}s that were\n   * removed.\n   */\n  removeAllActors () {\n    return this.getAllActors().map(actor => this.removeActor(actor));\n  }\n\n  /**\n   * Play the animation.\n   *\n   * @method rekapi.Rekapi#play\n   * @param {number} [iterations=-1] If omitted, the animation will loop\n   * endlessly.\n   * @return {rekapi.Rekapi}\n   */\n  play (iterations = -1) {\n    cancelLoop(this);\n\n    if (this._playState === PAUSED) {\n      // Move the playhead to the correct position in the timeline if resuming\n      // from a pause\n      this._loopTimestamp += Tweenable.now() - this._pausedAtTime;\n    } else {\n      this._loopTimestamp = Tweenable.now();\n    }\n\n    this._timesToIterate = iterations;\n    this._playState = PLAYING;\n\n    // Start the update loop\n    tick(this);\n\n    fireEvent(this, 'playStateChange');\n    fireEvent(this, 'play');\n\n    return this;\n  }\n\n  /**\n   * Move to a specific millisecond on the timeline and play from there.\n   *\n   * @method rekapi.Rekapi#playFrom\n   * @param {number} millisecond\n   * @param {number} [iterations] Works as it does in {@link\n   * rekapi.Rekapi#play}.\n   * @return {rekapi.Rekapi}\n   */\n  playFrom (millisecond, iterations) {\n    this.play(iterations);\n    this._loopTimestamp = Tweenable.now() - millisecond;\n\n    this._actors.forEach(\n      actor => actor._resetFnKeyframesFromMillisecond(millisecond)\n    );\n\n    return this;\n  }\n\n  /**\n   * Play from the last frame that was rendered with {@link\n   * rekapi.Rekapi#update}.\n   *\n   * @method rekapi.Rekapi#playFromCurrent\n   * @param {number} [iterations] Works as it does in {@link\n   * rekapi.Rekapi#play}.\n   * @return {rekapi.Rekapi}\n   */\n  playFromCurrent (iterations) {\n    return this.playFrom(this._lastUpdatedMillisecond, iterations);\n  }\n\n  /**\n   * Pause the animation.  A \"paused\" animation can be resumed from where it\n   * left off with {@link rekapi.Rekapi#play}.\n   *\n   * @method rekapi.Rekapi#pause\n   * @return {rekapi.Rekapi}\n   */\n  pause () {\n    if (this._playState === PAUSED) {\n      return this;\n    }\n\n    this._playState = PAUSED;\n    cancelLoop(this);\n    this._pausedAtTime = Tweenable.now();\n\n    fireEvent(this, 'playStateChange');\n    fireEvent(this, 'pause');\n\n    return this;\n  }\n\n  /**\n   * Stop the animation.  A \"stopped\" animation will start from the beginning\n   * if {@link rekapi.Rekapi#play} is called.\n   *\n   * @method rekapi.Rekapi#stop\n   * @return {rekapi.Rekapi}\n   */\n  stop () {\n    this._playState = STOPPED;\n    cancelLoop(this);\n\n    // Also kill any shifty tweens that are running.\n    this._actors.forEach(actor =>\n      actor._resetFnKeyframesFromMillisecond(0)\n    );\n\n    fireEvent(this, 'playStateChange');\n    fireEvent(this, 'stop');\n\n    return this;\n  }\n\n  /**\n   * @method rekapi.Rekapi#isPlaying\n   * @return {boolean} Whether or not the animation is playing (meaning not paused or\n   * stopped).\n   */\n  isPlaying () {\n    return this._playState === PLAYING;\n  }\n\n  /**\n   * @method rekapi.Rekapi#isPaused\n   * @return {boolean} Whether or not the animation is paused (meaning not playing or\n   * stopped).\n   */\n  isPaused () {\n    return this._playState === PAUSED;\n  }\n\n  /**\n   * @method rekapi.Rekapi#isStopped\n   * @return {boolean} Whether or not the animation is stopped (meaning not playing or\n   * paused).\n   */\n  isStopped () {\n    return this._playState === STOPPED;\n  }\n\n  /**\n   * Render an animation frame at a specific point in the timeline.\n   *\n   * @method rekapi.Rekapi#update\n   * @param {number} [millisecond=this._lastUpdatedMillisecond] The point in\n   * the timeline at which to render.  If omitted, this renders the last\n   * millisecond that was rendered (it's a re-render).\n   * @param {boolean} [doResetLaterFnKeyframes=false] If `true`, allow all\n   * {@link rekapi.keyframeFunction}s later in the timeline to be run again.\n   * This is a low-level feature, it should not be `true` (or even provided)\n   * for most use cases.\n   * @return {rekapi.Rekapi}\n   */\n  update (\n    millisecond = this._lastUpdatedMillisecond,\n    doResetLaterFnKeyframes = false\n  ) {\n    fireEvent(this, 'beforeUpdate');\n\n    const renderOrder = this.sort ?\n      _.sortBy(this._actors, this.sort) :\n      this._actors;\n\n    // Update and render each of the actors\n    renderOrder.forEach(actor => {\n      actor._updateState(millisecond, doResetLaterFnKeyframes);\n\n      if (actor.wasActive) {\n        actor.render(actor.context, actor.get());\n      }\n    });\n\n    this._lastUpdatedMillisecond = millisecond;\n    fireEvent(this, 'afterUpdate');\n\n    return this;\n  }\n\n  /**\n   * @method rekapi.Rekapi#getLastPositionUpdated\n   * @return {number} The normalized timeline position (between 0 and 1) that\n   * was last rendered.\n   */\n  getLastPositionUpdated () {\n    return (this._lastUpdatedMillisecond / this.getAnimationLength());\n  }\n\n  /**\n   * @method rekapi.Rekapi#getLastMillisecondUpdated\n   * @return {number} The millisecond that was last rendered.\n   */\n  getLastMillisecondUpdated () {\n    return this._lastUpdatedMillisecond;\n  }\n\n  /**\n   * @method rekapi.Rekapi#getAnimationLength\n   * @return {number} The length of the animation timeline, in milliseconds.\n   */\n  getAnimationLength () {\n    if (!this._animationLengthValid) {\n      this._animationLength = Math.max.apply(\n        Math,\n        this._actors.map(actor => actor.getEnd())\n      );\n\n      this._animationLengthValid = true;\n    }\n\n    return this._animationLength;\n  }\n\n  /**\n   * Bind a {@link rekapi.eventHandler} function to a Rekapi event.\n   * @method rekapi.Rekapi#on\n   * @param {string} eventName Valid values are:\n   *\n   * - `\"animationComplete\"`: Fires when all animation loops have completed.\n   * - `\"playStateChange\"`: Fires when the animation is played, paused, or\n   *   stopped.\n   * - `\"play\"`: Fires when the animation is {@link rekapi.Rekapi#play}ed.\n   * - `\"pause\"`: Fires when the animation is {@link rekapi.Rekapi#pause}d.\n   * - `\"stop\"`: Fires when the animation is {@link rekapi.Rekapi#stop}ped.\n   * - `\"beforeUpdate\"`: Fires each frame before all actors are rendered.\n   * - `\"afterUpdate\"`: Fires each frame after all actors are rendered.\n   * - `\"addActor\"`: Fires when an actor is added.  `data` is the\n   *   {@link rekapi.Actor} that was added.\n   * - `\"removeActor\"`: Fires when an actor is removed.  `data` is the {@link\n   *   rekapi.Actor} that was removed.\n   * - `\"beforeAddKeyframeProperty\"`: Fires just before the point where a\n   *   {@link rekapi.KeyframeProperty} is added to the timeline.  This event is\n   *   called before any modifications to the timeline are done.\n   * - `\"addKeyframeProperty\"`: Fires when a keyframe property is added.\n   *   `data` is the {@link rekapi.KeyframeProperty} that was added.\n   * - `\"beforeRemoveKeyframeProperty\"`: Fires just before the point where a\n   *   {@link rekapi.KeyframeProperty} is removed.  This\n   *   event is called before any modifications to the timeline are done.\n   * - `\"removeKeyframeProperty\"`: Fires when a {@link rekapi.KeyframeProperty}\n   *   is removed.  This event is fired _before_ the internal state of the\n   *   keyframe (but not the timeline, in contrast to the\n   *   `beforeRemoveKeyframeProperty` event) has been updated to reflect the\n   *   keyframe property removal (this is in contrast to\n   *   `removeKeyframePropertyComplete`).  `data` is the {@link\n   *   rekapi.KeyframeProperty} that was removed.\n   * - `\"removeKeyframePropertyComplete\"`: Fires when a {@link\n   *   rekapi.KeyframeProperty} has finished being removed from the timeline.\n   *   Unlike `removeKeyframeProperty`, this is fired _after_ the internal\n   *   state of Rekapi has been updated to reflect the removal of the keyframe\n   *   property. `data` is the {@link rekapi.KeyframeProperty} that was\n   *   removed.\n   * - `\"addKeyframePropertyTrack\"`: Fires when the a keyframe is added to an\n   *   actor that creates a new keyframe property track.  `data` is the {@link\n   *   rekapi.KeyframeProperty} that was added to create the property track.  A\n   *   reference to the actor that the keyframe property is associated with can\n   *   be accessed via `data.actor` and the track name that was added can be\n   *   determined via `data.name`.\n   * - `\"removeKeyframePropertyTrack\"`: Fires when the last keyframe property\n   *   in an actor's keyframe property track is removed.  Rekapi automatically\n   *   removes property tracks when they are emptied out, which causes this\n   *   event to be fired.  `data` is the name of the track that was\n   *   removed.\n   * - `\"timelineModified\"`: Fires when a keyframe is added, modified or\n   *   removed.\n   * - `\"animationLooped\"`: Fires when an animation loop ends and a new one\n   *   begins.\n   * @param {rekapi.eventHandler} handler The event handler function.\n   * @return {rekapi.Rekapi}\n   */\n  on (eventName, handler) {\n    if (!this._events[eventName]) {\n      return this;\n    }\n\n    this._events[eventName].push(handler);\n\n    return this;\n  }\n\n  /**\n   * Manually fire a Rekapi event, thereby calling all {@link\n   * rekapi.eventHandler}s bound to that event.\n   * @param {string} eventName The name of the event to trigger.\n   * @param {any} [data] Optional data to provide to the `eventName` {@link\n   * rekapi.eventHandler}s.\n   * @method rekapi.Rekapi#trigger\n   * @return {rekapi.Rekapi}\n   */\n  trigger (eventName, data) {\n    fireEvent(this, eventName, data);\n\n    return this;\n  }\n\n  /**\n   * Unbind one or more handlers from a Rekapi event.\n   * @method rekapi.Rekapi#off\n   * @param {string} eventName Valid values correspond to the list under\n   * {@link rekapi.Rekapi#on}.\n   * @param {rekapi.eventHandler} [handler] A reference to the {@link\n   * rekapi.eventHandler} to unbind.  If omitted, all {@link\n   * rekapi.eventHandler}s bound to `eventName` are unbound.\n   * @return {rekapi.Rekapi}\n   */\n  off (eventName, handler) {\n    if (!this._events[eventName]) {\n      return this;\n    }\n\n    this._events[eventName] = handler ?\n      _.without(this._events[eventName], handler) :\n      [];\n\n    return this;\n  }\n\n  /**\n   * Export the timeline to a `JSON.stringify`-friendly `Object`.\n   *\n   * @method rekapi.Rekapi#exportTimeline\n   * @return {Object} This data can later be consumed by {@link\n   * rekapi.Rekapi#importTimeline}.\n   */\n  exportTimeline () {\n    const exportData = {\n      duration: this.getAnimationLength(),\n      actors: this._actors.map(actor => actor.exportTimeline())\n    };\n\n\n    const curves = {};\n\n    _.chain(Tweenable.formulas)\n      .filter(formula => typeof formula.x1 === 'number')\n      .each(curve =>\n        curves[curve.displayName] =\n          _.pick(curve, 'displayName', 'x1', 'y1', 'x2', 'y2')\n      )\n      .value();\n\n    exportData.curves = curves;\n\n    return exportData;\n  }\n\n  /**\n   * Import data that was created by {@link rekapi.Rekapi#exportTimeline}.\n   * This sets up all actors, keyframes, and custom easing curves specified in\n   * the `rekapiData` parameter.  These two methods collectively allow you\n   * serialize an animation (for sending to a server for persistence, for\n   * example) and later recreating an identical animation.\n   *\n   * @method rekapi.Rekapi#importTimeline\n   * @param {Object} rekapiData Any object that has the same data format as the\n   * object generated from {@link rekapi.Rekapi#exportTimeline}.\n   */\n  importTimeline (rekapiData) {\n    _.each(rekapiData.curves, (curve, curveName) =>\n      setBezierFunction(\n        curveName,\n        curve.x1,\n        curve.y1,\n        curve.x2,\n        curve.y2\n      )\n    );\n\n    _.each(rekapiData.actors, actorData => {\n      const actor = new Actor();\n      actor.importTimeline(actorData);\n      this.addActor(actor);\n    });\n  }\n\n  /**\n   * @method rekapi.Rekapi#getEventNames\n   * @return {Array.<string>} The list of event names that this Rekapi instance\n   * supports.\n   */\n  getEventNames () {\n    return Object.keys(this._events);\n  }\n\n  /**\n   * Get a reference to a {@link rekapi.renderer} that was initialized for this\n   * animation.\n   * @method rekapi.Rekapi#getRendererInstance\n   * @param {rekapi.renderer} rendererConstructor The type of {@link\n   * rekapi.renderer} subclass (such as {@link rekapi.CanvasRenderer} or {@link\n   * rekapi.DOMRenderer}) to look up an instance of.\n   * @return {rekapi.renderer|undefined} The matching {@link rekapi.renderer},\n   * if any.\n   */\n  getRendererInstance (rendererConstructor) {\n    return this.renderers.filter(renderer =>\n      renderer instanceof rendererConstructor\n    )[0];\n  }\n\n  /**\n   * Move a {@link rekapi.Actor} around within the internal render order list.\n   * By default, a {@link rekapi.Actor} is rendered in the order it was added\n   * with {@link rekapi.Rekapi#addActor}.\n   *\n   * This method has no effect if {@link rekapi.Rekapi#sort} is set.\n   *\n   * @method rekapi.Rekapi#moveActorToPosition\n   * @param {rekapi.Actor} actor\n   * @param {number} layer This should be within `0` and the total number of\n   * {@link rekapi.Actor}s in the animation.  That number can be found with\n   * {@link rekapi.Rekapi#getActorCount}.\n   * @return {rekapi.Rekapi}\n   */\n  moveActorToPosition (actor, position) {\n    if (position < this._actors.length && position > -1) {\n      this._actors = _.without(this._actors, actor);\n      this._actors.splice(position, 0, actor);\n    }\n\n    return this;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/rekapi.js","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"lodash\"\n// module id = 1\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"shifty\"\n// module id = 2\n// module chunks = 0","import _, { noop } from 'lodash';\nimport { Tweenable } from 'shifty';\nimport { KeyframeProperty } from './keyframe-property';\nimport {\n  fireEvent,\n  invalidateAnimationLength,\n  DEFAULT_EASING\n} from './rekapi';\n\n/*!\n * @param {Object} obj\n * @return {number} millisecond\n */\nconst getMillisecond = obj => obj.millisecond;\n\n// TODO: Make this a prototype method\n/*!\n * @param {Actor} actor\n * @param {string} event\n * @param {any} [data]\n */\nconst fire = (actor, event, data) =>\n  actor.rekapi && fireEvent(actor.rekapi, event, data);\n\n/*!\n * Retrieves the most recent property cache entry for a given millisecond.\n * @param {Actor} actor\n * @param {number} millisecond\n * @return {(Object|undefined)} undefined if there is no property cache for\n * the millisecond, i.e. an empty cache.\n */\nconst getPropertyCacheEntryForMillisecond = (actor, millisecond) => {\n  const { _timelinePropertyCache } = actor;\n  const index = _.sortedIndex(\n    _timelinePropertyCache,\n    { _millisecond: millisecond },\n    obj => obj._millisecond\n  );\n\n  if (!_timelinePropertyCache[index]) {\n    return;\n  }\n\n  return _timelinePropertyCache[index]._millisecond === millisecond ?\n    _timelinePropertyCache[index] :\n      index >= 1 ?\n        _timelinePropertyCache[index - 1] :\n        _timelinePropertyCache[0];\n};\n\n/*!\n * Search property track `track` and find the correct index to insert a\n * new element at `millisecond`.\n * @param {Array(KeyframeProperty)} track\n * @param {number} millisecond\n * @return {number} index\n */\nconst insertionPointInTrack = (track, millisecond) =>\n  _.sortedIndex(track, { millisecond }, getMillisecond);\n\n/*!\n * Gets all of the current and most recent Rekapi.KeyframeProperties for a\n * given millisecond.\n * @param {Actor} actor\n * @param {number} forMillisecond\n * @return {Object} An Object containing Rekapi.KeyframeProperties\n */\nconst getLatestProperties = (actor, forMillisecond) => {\n  const latestProperties = {};\n\n  _.each(actor._propertyTracks, (propertyTrack, propertyName) => {\n    const index = insertionPointInTrack(propertyTrack, forMillisecond);\n\n    latestProperties[propertyName] =\n      propertyTrack[index] && propertyTrack[index].millisecond === forMillisecond ?\n        // Found forMillisecond exactly.\n        propertyTrack[index] :\n          index >= 1 ?\n            // forMillisecond doesn't exist in the track and index is\n            // where we'd need to insert it, therefore the previous\n            // keyframe is the most recent one before forMillisecond.\n            propertyTrack[index - 1] :\n            // Return first property.  This is after forMillisecond.\n            propertyTrack[0];\n  });\n\n  return latestProperties;\n};\n\n/*!\n * Search property track `track` and find the index to the element that is\n * at `millisecond`.  Returns `undefined` if not found.\n * @param {Array(KeyframeProperty)} track\n * @param {number} millisecond\n * @return {number} index or -1 if not present\n */\nconst propertyIndexInTrack = (track, millisecond) => {\n  const index = insertionPointInTrack(track, millisecond);\n\n  return track[index] && track[index].millisecond === millisecond ?\n    index : -1;\n};\n\n/*!\n * Mark the cache of internal KeyframeProperty data as invalid.  The cache\n * will be rebuilt on the next call to ensurePropertyCacheValid.\n * @param {Actor}\n */\nconst invalidateCache = actor => actor._timelinePropertyCacheValid = false;\n\n/*!\n * Empty out and rebuild the cache of internal KeyframeProperty data if it\n * has been marked as invalid.\n * @param {Actor}\n */\nconst ensurePropertyCacheValid = actor => {\n  if (actor._timelinePropertyCacheValid) {\n    return;\n  }\n\n  actor._timelinePropertyCache = [];\n  actor._timelineFunctionCache = [];\n\n  const { _timelinePropertyCache, _timelineFunctionCache } = actor;\n\n  // Build the cache map\n  const props = _.values(actor._keyframeProperties)\n    .sort((a, b) => a.millisecond - b.millisecond);\n\n  let curCacheEntry = getLatestProperties(actor, 0);\n\n  curCacheEntry._millisecond = 0;\n  _timelinePropertyCache.push(curCacheEntry);\n\n  props.forEach(property => {\n    if (property.millisecond !== curCacheEntry._millisecond) {\n      curCacheEntry = _.clone(curCacheEntry);\n      curCacheEntry._millisecond = property.millisecond;\n      _timelinePropertyCache.push(curCacheEntry);\n    }\n\n    curCacheEntry[property.name] = property;\n\n    if (property.name === 'function') {\n      _timelineFunctionCache.push(property);\n    }\n  });\n\n  actor._timelinePropertyCacheValid = true;\n};\n\n/*!\n * Remove any property tracks that are empty.\n *\n * @param {Actor} actor\n */\nconst removeEmptyPropertyTracks = actor => {\n  const { _propertyTracks } = actor;\n\n  Object.keys(_propertyTracks).forEach(trackName => {\n    if (!_propertyTracks[trackName].length) {\n      delete _propertyTracks[trackName];\n      fire(actor, 'removeKeyframePropertyTrack', trackName);\n    }\n  });\n};\n\n/*!\n * Stably sort all of the property tracks of an actor\n * @param {Actor} actor\n */\nconst sortPropertyTracks = actor => {\n  _.each(actor._propertyTracks, (propertyTrack, trackName) => {\n    propertyTrack = _.sortBy(propertyTrack, 'millisecond');\n\n    propertyTrack.forEach((keyframeProperty, i) =>\n      keyframeProperty.linkToNext(propertyTrack[i + 1])\n    );\n\n    actor._propertyTracks[trackName] = propertyTrack;\n  });\n};\n\n/*!\n * Updates internal Rekapi and Actor data after a KeyframeProperty\n * modification method is called.\n *\n * @param {Actor} actor\n */\nconst cleanupAfterKeyframeModification = actor => {\n  sortPropertyTracks(actor);\n  invalidateCache(actor);\n\n  if (actor.rekapi) {\n    invalidateAnimationLength(actor.rekapi);\n  }\n\n  fire(actor, 'timelineModified');\n};\n\n/**\n * A {@link rekapi.Actor} represents an individual component of an animation.\n * An animation may have one or many {@link rekapi.Actor}s.\n *\n * @param {Object} [config={}]\n * @param {(Object|CanvasRenderingContext2D|HTMLElement)} [config.context] Sets\n * {@link rekapi.Actor#context}.\n * @param {Function} [config.setup] Sets {@link rekapi.Actor#setup}.\n * @param {rekapi.render} [config.render] Sets {@link rekapi.Actor#render}.\n * @param {Function} [config.teardown] Sets {@link rekapi.Actor#teardown}.\n * @constructs rekapi.Actor\n */\nexport class Actor extends Tweenable {\n  constructor (config = {}) {\n    super();\n\n    /**\n     * @member {rekapi.Rekapi|undefined} rekapi.Actor#rekapi The {@link\n     * rekapi.Rekapi} instance to which this {@link rekapi.Actor} belongs, if\n     * any.\n     */\n\n    Object.assign(this, {\n      _propertyTracks: {},\n      _timelinePropertyCache: [],\n      _timelineFunctionCache: [],\n      _timelinePropertyCacheValid: false,\n      _keyframeProperties: {},\n\n      /**\n       * @member {string} rekapi.Actor#id The unique ID of this {@link rekapi.Actor}.\n       */\n      id: _.uniqueId(),\n\n      /**\n        * @member {(Object|CanvasRenderingContext2D|HTMLElement|undefined)}\n        * [rekapi.Actor#context] If this {@link rekapi.Actor} was created by or\n        * provided as an argument to {@link rekapi.Rekapi#addActor}, then this\n        * member is a reference to that {@link rekapi.Rekapi}'s {@link\n        * rekapi.Rekapi#context}.\n        */\n      context: config.context,\n\n      /**\n       * @member {Function} rekapi.Actor#setup Gets called when an actor is\n       * added to an animation by {@link rekapi.Rekapi#addActor}.\n       */\n      setup: config.setup || noop,\n\n      /**\n       * @member {rekapi.render} rekapi.Actor#render The function that renders\n       * this {@link rekapi.Actor}.\n       */\n      render: config.render || noop,\n\n      /**\n       * @member {Function} rekapi.Actor#teardown Gets called when an actor is\n       * removed from an animation by {@link rekapi.Rekapi#removeActor}.\n       */\n      teardown: config.teardown || noop,\n\n      /**\n       * @member {boolean} rekapi.Actor#wasActive A flag that records whether\n       * this {@link rekapi.Actor} had any state in the previous updated cycle.\n       * Handy for immediate-mode renderers (such as {@link\n       * rekapi.CanvasRenderer}) to prevent unintended renders after the actor\n       * has no state. Also used to prevent redundant {@link\n       * rekapi.keyframeFunction} calls.\n       */\n      wasActive: true\n    });\n  }\n\n  /**\n   * Create a keyframe for the actor.  The animation timeline begins at `0`.\n   * The timeline's length will automatically \"grow\" to accommodate new\n   * keyframes as they are added.\n   *\n   * `state` should contain all of the properties that define this keyframe's\n   * state.  These properties can be any value that can be tweened by\n   * [Shifty](http://jeremyckahn.github.io/shifty/doc/) (numbers,\n   * RGB/hexadecimal color strings, and CSS property strings).  `state` can\n   * also be a [function]{@link rekapi.keyframeFunction}, but\n   * [this works differently]{@tutorial keyframes-in-depth}.\n   *\n   * __Note:__ Internally, this creates {@link rekapi.KeyframeProperty}s and\n   * places them on a \"track.\" Tracks are automatically named to match the\n   * relevant {@link rekapi.KeyframeProperty#name}s.  These {@link\n   * rekapi.KeyframeProperty}s are managed for you by the {@link rekapi.Actor}\n   * APIs.\n   *\n   * ## [Click to learn about keyframes in depth]{@tutorial keyframes-in-depth}\n   * @method rekapi.Actor#keyframe\n   * @param {number} millisecond Where on the timeline to set the keyframe.\n   * @param {(Object|rekapi.keyframeFunction)} state The state properties of\n   * the keyframe.  If this is an Object, the properties will be interpolated\n   * between this and those of the following keyframe for a given point on the\n   * animation timeline.  If this is a function ({@link\n   * rekapi.keyframeFunction}), it will be called at the keyframe specified by\n   * `millisecond`.\n   * @param {(string|Object)} [easing] Optional easing string or Object.  If\n   * `state` is a function, this is ignored.\n   * @return {rekapi.Actor}\n   */\n  keyframe (millisecond, state, easing = DEFAULT_EASING) {\n    if (state instanceof Function) {\n      state = { 'function': state };\n    }\n\n    _.each(state, (value, name) =>\n      this.addKeyframeProperty(\n        new KeyframeProperty(\n          millisecond,\n          name,\n          value,\n          typeof easing === 'string' ?\n            easing :\n            (easing[name] || DEFAULT_EASING)\n        )\n      )\n    );\n\n    if (this.rekapi) {\n      invalidateAnimationLength(this.rekapi);\n    }\n\n    invalidateCache(this);\n    fire(this, 'timelineModified');\n\n    return this;\n  }\n\n  /**\n   * @method rekapi.Actor#hasKeyframeAt\n   * @param {number} millisecond Point on the timeline to query.\n   * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n   * lookup to a particular track.\n   * @return {boolean} Whether or not the actor has any {@link\n   * rekapi.KeyframeProperty}s set at `millisecond`.\n   */\n  hasKeyframeAt (millisecond, trackName = undefined) {\n    const { _propertyTracks } = this;\n\n    if (trackName && !_propertyTracks[trackName]) {\n      return false;\n    }\n\n    const propertyTracks = trackName ?\n      _.pick(_propertyTracks, trackName) :\n      _propertyTracks;\n\n    return Object.keys(propertyTracks).some(track =>\n      propertyTracks.hasOwnProperty(track) &&\n      !!this.getKeyframeProperty(track, millisecond)\n    );\n  }\n\n  /**\n   * Copies all of the {@link rekapi.KeyframeProperty}s from one point on the\n   * actor's timeline to another. This is particularly useful for animating an\n   * actor back to its original position.\n   *\n   *     actor\n   *       .keyframe(0, {\n   *         x: 10,\n   *         y: 15\n   *       }).keyframe(1000, {\n   *         x: 50,\n   *         y: 75\n   *       });\n   *\n   *     // Return the actor to its original position\n   *     actor.copyKeyframe(0, 2000);\n   *\n   * @method rekapi.Actor#copyKeyframe\n   * @param {number} copyFrom The timeline millisecond to copy {@link\n   * rekapi.KeyframeProperty}s from.\n   * @param {number} copyTo The timeline millisecond to copy {@link\n   * rekapi.KeyframeProperty}s to.\n   * @return {rekapi.Actor}\n   */\n  copyKeyframe (copyFrom, copyTo) {\n    // Build the configuation objects to be passed to Actor#keyframe\n    const sourcePositions = {};\n    const sourceEasings = {};\n\n    _.each(this._propertyTracks, (propertyTrack, trackName) => {\n      const keyframeProperty =\n        this.getKeyframeProperty(trackName, copyFrom);\n\n      if (keyframeProperty) {\n        sourcePositions[trackName] = keyframeProperty.value;\n        sourceEasings[trackName] = keyframeProperty.easing;\n      }\n    });\n\n    this.keyframe(copyTo, sourcePositions, sourceEasings);\n\n    return this;\n  }\n\n  /**\n   * Moves all of the {@link rekapi.KeyframeProperty}s from one point on the\n   * actor's timeline to another.  Although this method does error checking for\n   * you to make sure the operation can be safely performed, an effective\n   * pattern is to use {@link rekapi.Actor#hasKeyframeAt} to see if there is\n   * already a keyframe at the requested `to` destination.\n   *\n   * @method rekapi.Actor#moveKeyframe\n   * @param {number} from The millisecond of the keyframe to be moved.\n   * @param {number} to The millisecond of where the keyframe should be moved\n   * to.\n   * @return {boolean} Whether or not the keyframe was successfully moved.\n   */\n  moveKeyframe (from, to) {\n    if (!this.hasKeyframeAt(from) || this.hasKeyframeAt(to)) {\n      return false;\n    }\n\n    // Move each of the relevant KeyframeProperties to the new location in the\n    // timeline\n    _.each(this._propertyTracks, (propertyTrack, trackName) => {\n      const oldIndex = propertyIndexInTrack(propertyTrack, from);\n\n      if (oldIndex !== -1) {\n        propertyTrack[oldIndex].millisecond = to;\n      }\n    });\n\n    cleanupAfterKeyframeModification(this);\n\n    return true;\n  }\n\n  /**\n   * Augment the `value` or `easing` of the {@link rekapi.KeyframeProperty}s\n   * at a given millisecond.  Any {@link rekapi.KeyframeProperty}s omitted in\n   * `state` or `easing` are not modified.\n   *\n   *     actor.keyframe(0, {\n   *       'x': 10,\n   *       'y': 20\n   *     }).keyframe(1000, {\n   *       'x': 20,\n   *       'y': 40\n   *     }).keyframe(2000, {\n   *       'x': 30,\n   *       'y': 60\n   *     })\n   *\n   *     // Changes the state of the keyframe at millisecond 1000.\n   *     // Modifies the value of 'y' and the easing of 'x.'\n   *     actor.modifyKeyframe(1000, {\n   *       'y': 150\n   *     }, {\n   *       'x': 'easeFrom'\n   *     });\n   *\n   * @method rekapi.Actor#modifyKeyframe\n   * @param {number} millisecond\n   * @param {Object} state\n   * @param {Object} [easing={}]\n   * @return {rekapi.Actor}\n   */\n  modifyKeyframe (millisecond, state, easing = {}) {\n    _.each(this._propertyTracks, (propertyTrack, trackName) => {\n      const property = this.getKeyframeProperty(trackName, millisecond);\n\n      if (property) {\n        property.modifyWith({\n          value: state[trackName],\n          easing: easing[trackName]\n        });\n      } else if (state[trackName]) {\n        this.addKeyframeProperty(\n          new KeyframeProperty(\n            millisecond,\n            trackName,\n            state[trackName],\n            easing[trackName]\n          )\n        );\n      }\n    });\n\n    cleanupAfterKeyframeModification(this);\n\n    return this;\n  }\n\n  /**\n   * Remove all {@link rekapi.KeyframeProperty}s set\n   * on the actor at a given millisecond in the animation.\n   *\n   * @method rekapi.Actor#removeKeyframe\n   * @param {number} millisecond The location on the timeline of the keyframe\n   * to remove.\n   * @return {rekapi.Actor}\n   */\n  removeKeyframe (millisecond) {\n    _.each(this._propertyTracks, (propertyTrack, propertyName) => {\n      const index = propertyIndexInTrack(propertyTrack, millisecond);\n\n      if (index !== -1) {\n        const keyframeProperty = propertyTrack[index];\n        this._deleteKeyframePropertyAt(propertyTrack, index);\n        keyframeProperty.detach();\n      }\n    });\n\n    removeEmptyPropertyTracks(this);\n    cleanupAfterKeyframeModification(this);\n    fire(this, 'timelineModified');\n\n    return this;\n  }\n\n  /**\n   * Remove all {@link rekapi.KeyframeProperty}s set\n   * on the actor.\n   *\n   * **NOTE**: This method does _not_ fire the `beforeRemoveKeyframeProperty`\n   * or `removeKeyframePropertyComplete` events.  This method is a bulk\n   * operation that is more efficient than calling {@link\n   * rekapi.Actor#removeKeyframeProperty} many times individually, but\n   * foregoes firing events.\n   *\n   * @method rekapi.Actor#removeAllKeyframes\n   * @return {rekapi.Actor}\n   */\n  removeAllKeyframes () {\n    _.each(this._propertyTracks, propertyTrack =>\n      propertyTrack.length = 0\n    );\n\n    _.each(this._keyframeProperties, keyframeProperty =>\n      keyframeProperty.detach()\n    );\n\n    removeEmptyPropertyTracks(this);\n    this._keyframeProperties = {};\n\n    // Calling removeKeyframe performs some necessary post-removal cleanup, the\n    // earlier part of this method skipped all of that for the sake of\n    // efficiency.\n    return this.removeKeyframe(0);\n  }\n\n  /**\n   * @method rekapi.Actor#getKeyframeProperty\n   * @param {string} property The name of the property track.\n   * @param {number} millisecond The millisecond of the property in the\n   * timeline.\n   * @return {(rekapi.KeyframeProperty|undefined)} A {@link\n   * rekapi.KeyframeProperty} that is stored on the actor, as specified by the\n   * `property` and `millisecond` parameters. This is `undefined` if no\n   * properties were found.\n   */\n  getKeyframeProperty (property, millisecond) {\n    const propertyTrack = this._propertyTracks[property];\n\n    return propertyTrack[propertyIndexInTrack(propertyTrack, millisecond)];\n  }\n\n  /**\n   * Modify a {@link rekapi.KeyframeProperty} stored on an actor.\n   * Internally, this calls {@link rekapi.KeyframeProperty#modifyWith} and\n   * then performs some cleanup.\n   *\n   * @method rekapi.Actor#modifyKeyframeProperty\n   * @param {string} property The name of the {@link rekapi.KeyframeProperty}\n   * to modify.\n   * @param {number} millisecond The timeline millisecond of the {@link\n   * rekapi.KeyframeProperty} to modify.\n   * @param {Object} newProperties The properties to augment the {@link\n   * rekapi.KeyframeProperty} with.\n   * @return {rekapi.Actor}\n   */\n  modifyKeyframeProperty (property, millisecond, newProperties) {\n    const keyframeProperty = this.getKeyframeProperty(property, millisecond);\n\n    if (keyframeProperty) {\n      if ('millisecond' in newProperties &&\n          this.hasKeyframeAt(newProperties.millisecond, property)\n        ) {\n        throw new Error(\n          `Tried to move ${property} to ${newProperties.millisecond}ms, but a keyframe property already exists there`\n        );\n      }\n\n      keyframeProperty.modifyWith(newProperties);\n      cleanupAfterKeyframeModification(this);\n    }\n\n    return this;\n  }\n\n  /**\n   * Remove a single {@link rekapi.KeyframeProperty}\n   * from the actor.\n   * @method rekapi.Actor#removeKeyframeProperty\n   * @param {string} property The name of the {@link rekapi.KeyframeProperty}\n   * to remove.\n   * @param {number} millisecond Where in the timeline the {@link\n   * rekapi.KeyframeProperty} to remove is.\n   * @return {(rekapi.KeyframeProperty|undefined)} The removed\n   * KeyframeProperty, if one was found.\n   */\n  removeKeyframeProperty (property, millisecond) {\n    const { _propertyTracks } = this;\n\n    if (_propertyTracks[property]) {\n      const propertyTrack = _propertyTracks[property];\n      const index = propertyIndexInTrack(propertyTrack, millisecond);\n      const keyframeProperty = propertyTrack[index];\n\n      fireEvent(this.rekapi, 'beforeRemoveKeyframeProperty', keyframeProperty);\n      this._deleteKeyframePropertyAt(propertyTrack, index);\n      keyframeProperty.detach();\n\n      removeEmptyPropertyTracks(this);\n      cleanupAfterKeyframeModification(this);\n      fireEvent(this.rekapi, 'removeKeyframePropertyComplete', keyframeProperty);\n\n      return keyframeProperty;\n    }\n  }\n\n  /**\n   *\n   * @method rekapi.Actor#getTrackNames\n   * @return {Array.<rekapi.KeyframeProperty#name>} A list of all the track\n   * names for a {@link rekapi.Actor}.\n   */\n  getTrackNames () {\n    return Object.keys(this._propertyTracks);\n  }\n\n  /**\n   * Get all of the {@link rekapi.KeyframeProperty}s for a track.\n   * @method rekapi.Actor#getPropertiesInTrack\n   * @param {rekapi.KeyframeProperty#name} trackName The track name to query.\n   * @return {Array(rekapi.KeyframeProperty)}\n   */\n  getPropertiesInTrack (trackName) {\n    return (this._propertyTracks[trackName] || []).slice(0);\n  }\n\n  /**\n   * @method rekapi.Actor#getStart\n   * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n   * lookup to a particular track.\n   * @return {number} The millisecond of the first animating state of a {@link\n   * rekapi.Actor} (for instance, if the first keyframe is later than\n   * millisecond `0`).  If there are no keyframes, this is `0`.\n   */\n  getStart (trackName = undefined) {\n    const { _propertyTracks } = this;\n    const starts = [];\n\n    // Null check to see if trackName was provided and is valid\n    if (_propertyTracks.hasOwnProperty(trackName)) {\n      const firstKeyframeProperty = _propertyTracks[trackName][0];\n\n      if (firstKeyframeProperty) {\n        starts.push(firstKeyframeProperty.millisecond);\n      }\n    } else {\n      // Loop over all property tracks and accumulate the first\n      // keyframeProperties from non-empty tracks\n      _.each(_propertyTracks, propertyTrack => {\n        if (propertyTrack.length) {\n          starts.push(propertyTrack[0].millisecond);\n        }\n      });\n    }\n\n    return starts.length > 0 ?\n      Math.min.apply(Math, starts) :\n      0;\n  }\n\n  /**\n   * @method rekapi.Actor#getEnd\n   * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n   * lookup to a particular keyframe track.\n   * @return {number} The millisecond of the last state of an actor (the point\n   * in the timeline in which it is done animating).  If there are no\n   * keyframes, this is `0`.\n   */\n  getEnd (trackName = undefined) {\n    const endingTracks = [0];\n\n    const tracksToInspect = trackName ?\n      { [trackName]: this._propertyTracks[trackName] } :\n      this._propertyTracks;\n\n    _.each(tracksToInspect, propertyTrack => {\n      if (propertyTrack.length) {\n        endingTracks.push(propertyTrack[propertyTrack.length - 1].millisecond);\n      }\n    });\n\n    return Math.max.apply(Math, endingTracks);\n  }\n\n  /**\n   * @method rekapi.Actor#getLength\n   * @param {rekapi.KeyframeProperty#name} [trackName] Optionally scope the\n   * lookup to a particular track.\n   * @return {number} The length of time in milliseconds that the actor\n   * animates for.\n   */\n  getLength (trackName = undefined) {\n    return this.getEnd(trackName) - this.getStart(trackName);\n  }\n\n  /**\n   * Extend the last state on this actor's timeline to simulate a pause.\n   * Internally, this method copies the final state of the actor in the\n   * timeline to the millisecond defined by `until`.\n   *\n   * @method rekapi.Actor#wait\n   * @param {number} until At what point in the animation the Actor should wait\n   * until (relative to the start of the animation timeline).  If this number\n   * is less than the value returned from {@link rekapi.Actor#getLength},\n   * this method does nothing.\n   * @return {rekapi.Actor}\n   */\n  wait (until) {\n    const end = this.getEnd();\n\n    if (until <= end) {\n      return this;\n    }\n\n    const latestProps = getLatestProperties(this, this.getEnd());\n    const serializedProps = {};\n    const serializedEasings = {};\n\n    _.each(latestProps, (latestProp, propName) => {\n      serializedProps[propName] = latestProp.value;\n      serializedEasings[propName] = latestProp.easing;\n    });\n\n    this.modifyKeyframe(end, serializedProps, serializedEasings);\n    this.keyframe(until, serializedProps, serializedEasings);\n\n    return this;\n  }\n\n  /*!\n   * Insert a `KeyframeProperty` into a property track at `index`.  The linked\n   * list structure of the property track is maintained.\n   * @method rekapi.Actor#_insertKeyframePropertyAt\n   * @param {KeyframeProperty} keyframeProperty\n   * @param {Array(KeyframeProperty)} propertyTrack\n   * @param {number} index\n   */\n  _insertKeyframePropertyAt (keyframeProperty, propertyTrack, index) {\n    propertyTrack.splice(index, 0, keyframeProperty);\n  }\n\n  /*!\n   * Remove the `KeyframeProperty` at `index` from a property track.  The linked\n   * list structure of the property track is maintained.  The removed property\n   * is not modified or unlinked internally.\n   * @method rekapi.Actor#_deleteKeyframePropertyAt\n   * @param {Array(KeyframeProperty)} propertyTrack\n   * @param {number} index\n   */\n  _deleteKeyframePropertyAt (propertyTrack, index) {\n    propertyTrack.splice(index, 1);\n  }\n\n  /**\n   * Associate a {@link rekapi.KeyframeProperty} to this {@link rekapi.Actor}.\n   * Updates {@link rekapi.KeyframeProperty#actor} to maintain a link between\n   * the two objects.  This is a lower-level method and it is generally better\n   * to use {@link rekapi.Actor#keyframe}.  This is mostly useful for adding a\n   * {@link rekapi.KeyframeProperty} back to an actor after it was {@link\n   * rekapi.KeyframeProperty#detach}ed.\n   * @method rekapi.Actor#addKeyframeProperty\n   * @param {rekapi.KeyframeProperty} keyframeProperty\n   * @return {rekapi.Actor}\n   */\n  addKeyframeProperty (keyframeProperty) {\n    if (this.rekapi) {\n      fireEvent(this.rekapi, 'beforeAddKeyframeProperty', keyframeProperty);\n    }\n\n    keyframeProperty.actor = this;\n    this._keyframeProperties[keyframeProperty.id] = keyframeProperty;\n\n    const { name } = keyframeProperty;\n    const { _propertyTracks, rekapi } = this;\n\n    if (!this._propertyTracks[name]) {\n      _propertyTracks[name] = [keyframeProperty];\n\n      if (rekapi) {\n        fireEvent(rekapi, 'addKeyframePropertyTrack', keyframeProperty);\n      }\n    } else {\n      const index = insertionPointInTrack(_propertyTracks[name], keyframeProperty.millisecond);\n\n      if (_propertyTracks[name][index]) {\n        const newMillisecond = keyframeProperty.millisecond;\n        const targetMillisecond = _propertyTracks[name][index].millisecond;\n\n        if (targetMillisecond === newMillisecond) {\n          throw new Error(\n            `Cannot add duplicate ${name} keyframe property @ ${newMillisecond}ms`\n          );\n        } else if (rekapi && rekapi._warnOnOutOfOrderKeyframes) {\n          console.warn(\n            new Error(\n              `Added a keyframe property before end of ${name} track @ ${newMillisecond}ms (< ${targetMillisecond}ms)`\n            )\n          );\n        }\n      }\n\n      this._insertKeyframePropertyAt(keyframeProperty, _propertyTracks[name], index);\n      cleanupAfterKeyframeModification(this);\n    }\n\n    if (rekapi) {\n      fireEvent(rekapi, 'addKeyframeProperty', keyframeProperty);\n    }\n\n    return this;\n  }\n\n  /*!\n   * TODO: Explain the use case for this method\n   * Set the actor to be active or inactive starting at `millisecond`.\n   * @method rekapi.Actor#setActive\n   * @param {number} millisecond The time at which to change the actor's active state\n   * @param {boolean} isActive Whether the actor should be active or inactive\n   * @return {rekapi.Actor}\n   */\n  setActive (millisecond, isActive) {\n    const hasActiveTrack = !!this._propertyTracks._active;\n    const activeProperty = hasActiveTrack\n        && this.getKeyframeProperty('_active', millisecond);\n\n    if (activeProperty) {\n      activeProperty.value = isActive;\n    } else {\n      this.addKeyframeProperty(\n        new KeyframeProperty(millisecond, '_active', isActive)\n      );\n    }\n\n    return this;\n  }\n\n  /*!\n   * Calculate and set the actor's position at `millisecond` in the animation.\n   * @method rekapi.Actor#_updateState\n   * @param {number} millisecond\n   * @param {boolean} [resetLaterFnKeyframes] If true, allow all function\n   * keyframes later in the timeline to be run again.\n   */\n  _updateState (millisecond, resetLaterFnKeyframes = false) {\n    const start = this.getStart();\n    const end = this.getEnd();\n    const interpolatedObject = {};\n\n    millisecond = Math.min(end, millisecond);\n\n    ensurePropertyCacheValid(this);\n\n    const propertyCacheEntry =\n      _.omit(\n        getPropertyCacheEntryForMillisecond(this, millisecond),\n        '_millisecond'\n      );\n\n    // All actors are active at time 0 unless otherwise specified;\n    // make sure a future time deactivation doesn't deactive the actor\n    // by default.\n    if (propertyCacheEntry._active\n        && millisecond >= propertyCacheEntry._active.millisecond) {\n\n      this.wasActive = propertyCacheEntry._active.getValueAt(millisecond);\n\n      if (!this.wasActive) {\n        return this;\n      }\n    } else {\n      this.wasActive = true;\n    }\n\n    if (start === end) {\n      // If there is only one keyframe, use that for the state of the actor\n      _.each(propertyCacheEntry, (keyframeProperty, propName) => {\n        if (keyframeProperty.shouldInvokeForMillisecond(millisecond)) {\n          keyframeProperty.invoke();\n          keyframeProperty.hasFired = false;\n          return;\n        }\n\n        interpolatedObject[propName] = keyframeProperty.value;\n      });\n\n    } else {\n      _.each(propertyCacheEntry, (keyframeProperty, propName) => {\n        if (this._beforeKeyframePropertyInterpolate !== noop) {\n          this._beforeKeyframePropertyInterpolate(keyframeProperty);\n        }\n\n        if (keyframeProperty.shouldInvokeForMillisecond(millisecond)) {\n          keyframeProperty.invoke();\n          return;\n        }\n\n        interpolatedObject[propName] =\n          keyframeProperty.getValueAt(millisecond);\n\n        if (this._afterKeyframePropertyInterpolate !== noop) {\n          this._afterKeyframePropertyInterpolate(\n            keyframeProperty, interpolatedObject);\n        }\n      });\n    }\n\n    this.set(interpolatedObject);\n\n    if (!resetLaterFnKeyframes) {\n      this._resetFnKeyframesFromMillisecond(millisecond);\n    }\n\n    return this;\n  }\n\n  /*!\n   * @method rekapi.Actor#_resetFnKeyframesFromMillisecond\n   * @param {number} millisecond\n   */\n  _resetFnKeyframesFromMillisecond (millisecond) {\n    const cache = this._timelineFunctionCache;\n    const { length } = cache;\n    let index = _.sortedIndex(cache, { millisecond: millisecond }, getMillisecond);\n\n    while (index < length) {\n      cache[index++].hasFired = false;\n    }\n  }\n\n  /**\n   * Export this {@link rekapi.Actor} to a `JSON.stringify`-friendly `Object`.\n   * @method rekapi.Actor#exportTimeline\n   * @return {Object} This data can later be consumed by {@link\n   * rekapi.Actor#importTimeline}.\n   */\n  exportTimeline () {\n    const exportData = {\n      start: this.getStart(),\n      end: this.getEnd(),\n      trackNames: this.getTrackNames(),\n      propertyTracks: {}\n    };\n\n    _.each(this._propertyTracks, (propertyTrack, trackName) => {\n      const track = [];\n\n      _.each(propertyTrack, keyframeProperty => {\n        track.push(keyframeProperty.exportPropertyData());\n      });\n\n      exportData.propertyTracks[trackName] = track;\n    });\n\n    return exportData;\n  }\n\n  /**\n   * Import an Object to augment this actor's state.  This does not remove\n   * keyframe properties before importing new ones.\n   *\n   * @method rekapi.Actor#importTimeline\n   * @param {Object} actorData Any object that has the same data format as the\n   * object generated from {@link rekapi.Actor#exportTimeline}.\n   */\n  importTimeline (actorData) {\n    _.each(actorData.propertyTracks, propertyTrack => {\n      _.each(propertyTrack, property => {\n        this.keyframe(\n          property.millisecond,\n          { [property.name]: property.value },\n          property.easing\n        );\n      });\n    });\n  }\n}\n\nObject.assign(Actor.prototype, {\n  /*!\n   * @method rekapi.Actor#_beforeKeyframePropertyInterpolate\n   * @param {KeyframeProperty} keyframeProperty\n   * @abstract\n   */\n  _beforeKeyframePropertyInterpolate: noop,\n\n  /*!\n   * @method rekapi.Actor#_afterKeyframePropertyInterpolate\n   * @param {KeyframeProperty} keyframeProperty\n   * @param {Object} interpolatedObject\n   * @abstract\n   */\n  _afterKeyframePropertyInterpolate: noop\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/actor.js","import _ from 'lodash';\nimport { interpolate } from 'shifty';\nimport {\n  fireEvent\n} from './rekapi';\n\nconst DEFAULT_EASING = 'linear';\n\n/**\n * Represents an individual component of an {@link rekapi.Actor}'s keyframe\n * state.  In most cases you won't need to deal with this object directly, as\n * the {@link rekapi.Actor} APIs abstract a lot of what this Object does away\n * for you.\n * @param {number} millisecond Sets {@link\n * rekapi.KeyframeProperty#millisecond}.\n * @param {string} name Sets {@link rekapi.KeyframeProperty#name}.\n * @param {(number|string|boolean|rekapi.keyframeFunction)} value Sets {@link\n * rekapi.KeyframeProperty#value}.\n * @param {string} [easing=\"linear\"] Sets {@link\n * rekapi.KeyframeProperty#easing}.\n * @constructs rekapi.KeyframeProperty\n */\nexport class KeyframeProperty {\n  constructor (millisecond, name, value, easing = DEFAULT_EASING) {\n    /**\n     * @member {string} rekapi.KeyframeProperty#id The unique ID of this {@link\n     * rekapi.KeyframeProperty}.\n     */\n    this.id = _.uniqueId('keyframeProperty_');\n\n    /**\n     * @member {boolean} rekapi.KeyframeProperty#hasFired Flag to determine if\n     * this {@link rekapi.KeyframeProperty}'s {@link rekapi.keyframeFunction}\n     * should be invoked in the current animation loop.\n     */\n    this.hasFired = null;\n\n    /**\n     * @member {(rekapi.Actor|undefined)} rekapi.KeyframeProperty#actor The\n     * {@link rekapi.Actor} to which this {@link rekapi.KeyframeProperty}\n     * belongs, if any.\n     */\n\n    /**\n     * @member {(rekapi.KeyframeProperty|null)}\n     * rekapi.KeyframeProperty#nextProperty A reference to the {@link\n      * rekapi.KeyframeProperty} that follows this one in a {@link\n      * rekapi.Actor}'s property track.\n     */\n    this.nextProperty = null;\n\n    Object.assign(this, {\n      /**\n       * @member {number} rekapi.KeyframeProperty#millisecond Where on the\n       * animation timeline this {@link rekapi.KeyframeProperty} is.\n       */\n      millisecond,\n      /**\n       * @member {string} rekapi.KeyframeProperty#name This {@link\n       * rekapi.KeyframeProperty}'s name, such as `\"x\"` or `\"opacity\"`.\n       */\n      name,\n      /**\n       * @member {number|string|boolean|rekapi.keyframeFunction}\n       * rekapi.KeyframeProperty#value The value that this {@link\n       * rekapi.KeyframeProperty} represents.\n       */\n      value,\n      /**\n       * @member {string} rekapi.KeyframeProperty#easing The easing curve by\n       * which this {@link rekapi.KeyframeProperty} should be animated.\n       */\n      easing\n    });\n  }\n\n  /**\n   * Modify this {@link rekapi.KeyframeProperty}.\n   * @method rekapi.KeyframeProperty#modifyWith\n   * @param {Object} newProperties Valid values are:\n   * @param {number} [newProperties.millisecond] Sets {@link\n   * rekapi.KeyframeProperty#millisecond}.\n   * @param {string} [newProperties.name] Sets {@link rekapi.KeyframeProperty#name}.\n   * @param {(number|string|boolean|rekapi.keyframeFunction)} [newProperties.value] Sets {@link\n   * rekapi.KeyframeProperty#value}.\n   * @param {string} [newProperties.easing] Sets {@link\n   * rekapi.KeyframeProperty#easing}.\n   */\n  modifyWith (newProperties) {\n    Object.assign(this, newProperties);\n  }\n\n  /**\n   * Calculate the midpoint between this {@link rekapi.KeyframeProperty} and\n   * the next {@link rekapi.KeyframeProperty} in a {@link rekapi.Actor}'s\n   * property track.\n   *\n   * In just about all cases, `millisecond` should be between this {@link\n   * rekapi.KeyframeProperty}'s `millisecond` and the `millisecond` of the\n   * {@link rekapi.KeyframeProperty} that follows it in the animation\n   * timeline, but it is valid to specify a value outside of this range.\n   * @method rekapi.KeyframeProperty#getValueAt\n   * @param {number} millisecond The millisecond in the animation timeline to\n   * compute the state value for.\n   * @return {(number|string|boolean|rekapi.keyframeFunction|rekapi.KeyframeProperty#value)}\n   */\n  getValueAt (millisecond) {\n    const nextProperty = this.nextProperty;\n\n    if (typeof this.value === 'boolean') {\n      return this.value;\n    } else if (nextProperty) {\n      const boundedMillisecond = Math.min(\n        Math.max(millisecond, this.millisecond),\n        nextProperty.millisecond\n      );\n\n      const { name } = this;\n      const delta = nextProperty.millisecond - this.millisecond;\n      const interpolatePosition =\n        (boundedMillisecond - this.millisecond) / delta;\n\n      return interpolate(\n        { [name]: this.value },\n        { [name]: nextProperty.value },\n        interpolatePosition,\n        nextProperty.easing\n      )[name];\n    } else {\n      return this.value;\n    }\n  }\n\n  /**\n   * Create the reference to the {@link rekapi.KeyframeProperty} that follows\n   * this one on a {@link rekapi.Actor}'s property track.  Property tracks\n   * are just linked lists of {@link rekapi.KeyframeProperty}s.\n   * @method rekapi.KeyframeProperty#linkToNext\n   * @param {KeyframeProperty=} nextProperty The {@link\n   * rekapi.KeyframeProperty} that should immediately follow this one on the\n   * animation timeline.\n   */\n  linkToNext (nextProperty = null) {\n    this.nextProperty = nextProperty;\n  }\n\n  /**\n   * Disassociates this {@link rekapi.KeyframeProperty} from its {@link\n   * rekapi.Actor}.  This is called by various {@link rekapi.Actor} methods\n   * and triggers the [removeKeyframeProperty]{@link rekapi.Rekapi#on} event\n   * on the associated {@link rekapi.Rekapi} instance.\n   * @method rekapi.KeyframeProperty#detach\n   */\n  detach () {\n    const { actor } = this;\n\n    if (actor && actor.rekapi) {\n      fireEvent(actor.rekapi, 'removeKeyframeProperty', this);\n      delete actor._keyframeProperties[this.id];\n      this.actor = null;\n    }\n\n    return this;\n  }\n\n  /**\n   * Export this {@link rekapi.KeyframeProperty} to a `JSON.stringify`-friendly\n   * `Object`.\n   * @method rekapi.KeyframeProperty#exportPropertyData\n   * @return {Object}\n   */\n  exportPropertyData () {\n    return _.pick(this, ['millisecond', 'name', 'value', 'easing']);\n  }\n\n  /*!\n   * Whether or not this is a function keyframe and should be invoked for the\n   * current frame.  Helper method for Actor.\n   * @method rekapi.KeyframeProperty#shouldInvokeForMillisecond\n   * @return {boolean}\n   */\n  shouldInvokeForMillisecond (millisecond) {\n    return (millisecond >= this.millisecond &&\n      this.name === 'function' &&\n      !this.hasFired\n    );\n  }\n\n  /**\n   * Calls {@link rekapi.KeyframeProperty#value} if it is a {@link\n   * rekapi.keyframeFunction}.\n   * @method rekapi.KeyframeProperty#invoke\n   * @return {any} Whatever value is returned for this {@link\n   * rekapi.KeyframeProperty}'s {@link rekapi.keyframeFunction}.\n   */\n  invoke () {\n    const drift = this.actor.rekapi._loopPosition - this.millisecond;\n    const returnValue = this.value(this.actor, drift);\n    this.hasFired = true;\n\n    return returnValue;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/keyframe-property.js","import _ from 'lodash';\nimport Rekapi, {\n  rendererBootstrappers\n} from '../rekapi';\n\n// PRIVATE UTILITY FUNCTIONS\n//\n\n/*!\n * Gets (and optionally sets) height or width on a canvas.\n * @param {HTMLCanvas} canvas\n * @param {string} heightOrWidth The dimension (either \"height\" or \"width\")\n * to get or set.\n * @param {number=} newSize The new value to set for `dimension`.\n * @return {number}\n */\nconst dimension = (canvas, heightOrWidth, newSize = undefined) => {\n  if (newSize !== undefined) {\n    canvas[heightOrWidth] = newSize;\n    canvas.style[heightOrWidth] = `${newSize}px`;\n  }\n\n  return canvas[heightOrWidth];\n};\n\n// CANVAS RENDERER OBJECT\n//\n\n/**\n * You can use Rekapi to render animations to an HTML5 `<canvas>`.  To do so,\n * just provide a\n * [`CanvasRenderingContext2D`](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)\n * instance to the {@link rekapi.Rekapi} constructor to\n * automatically set up the renderer:\n *\n *     const rekapi = new Rekapi(document.createElement('canvas').getContext('2d'));\n *\n *  To use this renderer's API, get a reference to the initialized object:\n *\n *     const canvasRenderer = rekapi.getRendererInstance(CanvasRenderer);\n *\n * __Note__: {@link rekapi.CanvasRenderer} is added to {@link\n * rekapi.Rekapi#renderers} automatically, there is no reason to call the\n * constructor yourself in most cases.\n * @param {rekapi.Rekapi} rekapi The {@link rekapi.Rekapi} instance to render for.\n * @param {CanvasRenderingContext2D=} context See [the canvas\n * docs](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D).\n * @constructor rekapi.CanvasRenderer\n * @extends {rekapi.renderer}\n */\nexport class CanvasRenderer {\n\n  constructor (rekapi, context = undefined) {\n    Object.assign(this, {\n      rekapi,\n      canvasContext: context || rekapi.context\n    });\n\n    rekapi.on('beforeUpdate', () => this.clear());\n  }\n\n  /**\n   * Get and optionally set the height of the associated `<canvas>` element.\n   * @method rekapi.CanvasRenderer#height\n   * @param {number} [height] The height to optionally set.\n   * @return {number}\n   */\n  height (height = undefined) {\n    return dimension(this.canvasContext.canvas, 'height', height);\n  }\n\n  /**\n   * Get and optionally set the width of the associated `<canvas>` element.\n   * @method rekapi.CanvasRenderer#width\n   * @param {number} [width] The width to optionally set.\n   * @return {number}\n   */\n  width (width = undefined) {\n    return dimension(this.canvasContext.canvas, 'width', width);\n  }\n\n  /**\n   * Erase the `<canvas>`.\n   * @method rekapi.CanvasRenderer#clear\n   * @return {rekapi.CanvasRenderer}\n   */\n  clear () {\n    this.canvasContext.clearRect(0, 0, this.width(), this.height());\n\n    return this;\n  }\n}\n\n/*!\n * Sets up an instance of CanvasRenderer and attaches it to a `Rekapi`\n * instance.  Also augments the Rekapi instance with canvas-specific\n * functions.\n * @param {Rekapi} rekapi\n */\nrendererBootstrappers.push(rekapi => {\n  if (typeof CanvasRenderingContext2D === 'undefined' ||\n    !(rekapi.context instanceof CanvasRenderingContext2D)) {\n\n    return;\n  }\n\n  return new CanvasRenderer(rekapi);\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderers/canvas.js","import _ from 'lodash';\nimport { Tweenable } from 'shifty';\nimport Rekapi, {\n  rendererBootstrappers,\n  fireEvent\n} from '../rekapi';\n\nconst { now } = Tweenable;\n\nconst vendorTransforms = [\n  'transform',\n  'webkitTransform',\n  'MozTransform',\n  'oTransform',\n  'msTransform'\n];\n\nexport const transformFunctions = [\n  'translateX',\n  'translateY',\n  'translateZ',\n  'scale',\n  'scaleX',\n  'scaleY',\n  'perspective',\n  'rotate',\n  'rotateX',\n  'rotateY',\n  'rotateZ',\n  'skewX',\n  'skewY'\n];\n\nconst DEFAULT_FPS = 30;\nexport const TRANSFORM_TOKEN = 'TRANSFORM';\nexport const VENDOR_TOKEN = 'VENDOR';\nconst R_TRANSFORM_TOKEN = new RegExp(TRANSFORM_TOKEN, 'g');\nconst R_VENDOR_TOKEN = new RegExp(VENDOR_TOKEN, 'g');\nconst VENDOR_PREFIXES = {\n  microsoft: '-ms-',\n  mozilla: '-moz-',\n  opera: '-o-',\n  w3: '',\n  webkit: '-webkit-'\n};\nconst BEZIERS = {\n  linear: '.25,.25,.75,.75',\n  easeInQuad: '.55,.085,.68,.53',\n  easeInCubic: '.55,.055,.675,.19',\n  easeInQuart: '.895,.03,.685,.22',\n  easeInQuint: '.755,.05,.855,.06',\n  easeInSine: '.47,0,.745,.715',\n  easeInExpo: '.95,.05,.795,.035',\n  easeInCirc: '.6,.04,.98, .335',\n  easeOutQuad: '.25,.46,.45,.94',\n  easeOutCubic: '.215,.61,.355,1',\n  easeOutQuart: '.165,.84,.44,1',\n  easeOutQuint: '.23,1,.32,1',\n  easeOutSine: '.39,.575,.565,1',\n  easeOutExpo: '.19,1,.22,1',\n  easeOutCirc: '.075,.82,.165,1',\n  easeInOutQuad: '.455,.03,.515,.955',\n  easeInOutCubic: '.645,.045,.355,1',\n  easeInOutQuart: '.77,0,.175,1',\n  easeInOutQuint: '.86,0.07,1',\n  easeInOutSine: '.445,.05,.55,.95',\n  easeInOutExpo: '1,0,0,1',\n  easeInOutCirc: '.785,.135,.15,.86'\n};\n\n// The timer to remove an injected style isn't likely to match the actual\n// length of the CSS animation, so give it some extra time to complete so it\n// doesn't cut off the end.\nconst INJECTED_STYLE_REMOVAL_BUFFER_MS = 250;\n\nconst R_3D_RULE = /3d\\(/g;\nconst _3D_RULE = '3d(';\nconst _3D_TOKEN = '__THREED__';\n\n// PRIVATE UTILITY FUNCTIONS\n//\n\n/*!\n * http://stackoverflow.com/a/3886106\n *\n * @param {number} number\n */\nconst isInt = number => number % 1 === 0;\n\n/*!\n * @return {string}\n */\nconst vendorPrefix = (() => {\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  const { style } = document.body;\n\n  return (\n    '-webkit-animation' in style ? 'webkit'    :\n    '-moz-animation'    in style ? 'mozilla'   :\n    '-ms-animation'     in style ? 'microsoft' :\n    '-o-animation'      in style ? 'opera'     :\n    'animation'         in style ? 'w3'        :\n    ''\n  );\n})();\n\n/*!\n * @param {Actor} actor\n * @return {string} The default CSS class that is targeted by {@link\n * rekapi.DOMRenderer#getCss} if a custom class is not specified.  This may be\n * useful for getting a standard and consistent CSS class name for an actor's\n * DOM element.\n */\nconst getActorClassName = actor => `actor-${actor.id}`;\n\n/*!\n * Fixes a really bizarre issue that only seems to affect Presto and Blink.\n * In some situations, DOM nodes will not detect dynamically injected <style>\n * elements.  Explicitly re-inserting DOM nodes seems to fix the issue.  Not\n * sure what causes this issue.  Not sure why this fixes it.\n *\n * @param {Rekapi} rekapi\n */\nconst forceStyleReset = rekapi => {\n  const dummyDiv = document.createElement('div');\n\n  _.each(rekapi.getAllActors(), actor => {\n    if (actor.context.nodeType === 1) {\n      const { context } = actor;\n      const { parentElement } = context;\n\n      parentElement.replaceChild(dummyDiv, context);\n      parentElement.replaceChild(context, dummyDiv);\n    }\n  });\n};\n\nlet styleID = 0;\n/*!\n * @param {Rekapi} rekapi\n * @param {string} css The css content that the <style> element should have.\n * @return {HTMLStyleElement} The unique ID of the injected <style> element.\n */\nconst injectStyle = (rekapi, css) => {\n  const style = document.createElement('style');\n  const id = `rekapi-${styleID++}`;\n  style.id = id;\n  style.innerHTML = css;\n  document.head.appendChild(style);\n  forceStyleReset(rekapi);\n\n  return style;\n};\n\n/*!\n * @param {HTMLElement} element\n * @param {string} styleName\n * @param {string|number} styleValue\n */\nconst setStyle = (element, styleName, styleValue) =>\n  element.style[styleName] = styleValue;\n\n/*!\n * @param {string} name A transform function name\n * @return {boolean}\n */\nconst isTransformFunction = name => _.contains(transformFunctions, name);\n\n/*!\n * Builds a concatenated string of given transform property values in order.\n *\n * @param {Array.<string>} orderedTransforms Array of ordered transform\n *     function names\n * @param {Object} transformProperties Transform properties to build together\n * @return {string}\n */\nconst buildTransformValue = (orderedTransforms, transformProperties) => {\n  const transformComponents = [];\n\n  _.each(orderedTransforms, functionName => {\n    if (transformProperties[functionName] !== undefined) {\n      transformComponents.push(\n        `${functionName}(${transformProperties[functionName]})`\n      );\n    }\n  });\n\n  return transformComponents.join(' ');\n};\n\n/*!\n * Sets value for all vendor prefixed transform properties on an element\n *\n * @param {HTMLElement} element The actor's DOM element\n * @param {string} transformValue The transform style value\n */\nconst setTransformStyles = (element, transformValue) =>\n  vendorTransforms.forEach(prefixedTransform =>\n    setStyle(element, prefixedTransform, transformValue)\n  );\n\n/*!\n * @param {Actor} actor\n * @param {HTMLElement} element\n * @param {Object} state\n */\nconst actorRender = (actor, element, state) => {\n  const propertyNames = Object.keys(state);\n  // TODO:  Optimize the following code so that propertyNames is not looped\n  // over twice.\n  const transformFunctionNames = propertyNames.filter(isTransformFunction);\n  const otherProperties = _.pick(\n    state,\n    _.reject(propertyNames, isTransformFunction)\n  );\n\n  if (transformFunctionNames.length) {\n    setTransformStyles(element,\n      buildTransformValue(\n        actor._transformOrder,\n        _.pick(state, transformFunctionNames)\n      )\n    );\n  } else if (state.transform) {\n    setTransformStyles(element, state.transform);\n  }\n\n  _.each(otherProperties, (styleValue, styleName) =>\n    setStyle(element, styleName, styleValue)\n  );\n};\n\n/*!\n * @param {Actor} actor\n */\nconst actorTeardown = actor => {\n  const { context } = actor;\n  const classList = context.className.match(/\\S+/g);\n  const sanitizedClassList =\n    _.without(classList, getActorClassName(actor));\n  context.className = sanitizedClassList.join(' ');\n};\n\n/*!\n * transform properties like translate3d and rotate3d break the cardinality\n * of multi-ease easing strings, because the \"3\" gets treated like a\n * tweenable value.  Transform \"3d(\" to \"__THREED__\" to prevent this, and\n * transform it back in _afterKeyframePropertyInterpolate.\n *\n * @param {KeyframeProperty} keyframeProperty\n */\nconst _beforeKeyframePropertyInterpolate = keyframeProperty => {\n  if (keyframeProperty.name !== 'transform') {\n    return;\n  }\n\n  const { value, nextProperty } = keyframeProperty;\n\n  if (nextProperty && value.match(R_3D_RULE)) {\n    keyframeProperty.value = value.replace(R_3D_RULE, _3D_TOKEN);\n    nextProperty.value = nextProperty.value.replace(R_3D_RULE, _3D_TOKEN);\n  }\n};\n\n/*!\n * @param {KeyframeProperty} keyframeProperty\n * @param {Object} interpolatedObject\n */\nconst _afterKeyframePropertyInterpolate = (keyframeProperty, interpolatedObject) => {\n  if (keyframeProperty.name !== 'transform') {\n    return;\n  }\n\n  const { value, nextProperty, name } = keyframeProperty;\n\n  if (nextProperty && value.match(_3D_TOKEN)) {\n    keyframeProperty.value = value.replace(_3D_TOKEN, _3D_RULE);\n    nextProperty.value = nextProperty.value.replace(_3D_TOKEN, _3D_RULE);\n    interpolatedObject[name] =\n      interpolatedObject[name].replace(_3D_TOKEN, _3D_RULE);\n  }\n};\n\n/*!\n * @param {Rekapi} rekapi\n * @param {Actor} actor\n */\nconst onAddActor = (rekapi, actor) => {\n  const { context } = actor;\n\n  if (context.nodeType !== 1) {\n    return;\n  }\n\n  const className = getActorClassName(actor);\n\n  // Add the class if it's not already there.\n  // Using className instead of classList to make IE happy.\n  if (!context.className.match(className)) {\n    context.className += ` ${className}`;\n  }\n\n  Object.assign(actor, {\n    render: actorRender.bind(actor, actor),\n    teardown: actorTeardown.bind(actor, actor),\n    _transformOrder: transformFunctions.slice(0),\n    _beforeKeyframePropertyInterpolate,\n    _afterKeyframePropertyInterpolate\n  });\n};\n\n/*!\n * @param {string} keyframes\n * @param {vendor} vendor\n * @return {string}\n */\nexport const applyVendorPropertyPrefixes = (keyframes, vendor) =>\n  keyframes\n    .replace(\n      R_VENDOR_TOKEN,\n      VENDOR_PREFIXES[vendor]\n    )\n    .replace(\n      R_TRANSFORM_TOKEN,\n      `${VENDOR_PREFIXES[vendor]}transform`\n    );\n\n/*!\n * @param {string} toKeyframes Generated keyframes to wrap in boilerplates\n * @param {string} animName\n * @param {Array.<string>=} vendors Vendor boilerplates to be applied.\n *     Should be any of the values in Rekapi.util.VENDOR_PREFIXES.\n * @return {string}\n */\nexport const applyVendorBoilerplates = (toKeyframes, animName, vendors = ['w3']) =>\n  vendors.map(vendor =>\n    applyVendorPropertyPrefixes(\n      `@${VENDOR_PREFIXES[vendor]}keyframes ${animName}-keyframes {\n${''  }${toKeyframes}\n${''  }}`,\n      vendor)\n  ).join('\\n');\n\n/*!\n * @param {KeyframeProperty} property\n * @param {number} fromPercent\n * @param {number} toPercent\n * @return {string}\n */\nexport const generateOptimizedKeyframeSegment = (\n  property,\n  fromPercent,\n  toPercent\n) => {\n  const name = property.name === 'transform' ?\n    TRANSFORM_TOKEN :\n    property.name;\n\n  const { nextProperty, value } = property;\n  const from = isInt(fromPercent) ? fromPercent : fromPercent.toFixed(2);\n  const to = isInt(toPercent) ? toPercent : toPercent.toFixed(2);\n  const bezier = BEZIERS[nextProperty.easing.split(' ')[0]];\n\n  return (\n `  ${from}% {${name}:${value};${''\n  }${VENDOR_TOKEN}animation-timing-function: cubic-bezier(${bezier});${''\n  }}\n  ${to}% {${name}:${nextProperty.value};}`\n  );\n};\n\n/*!\n * @param {Object} propsToSerialize\n * @param {Array.<string>} transformNames\n * @return {Object}\n */\nexport const combineTranfromProperties = (propsToSerialize, transformNames) => {\n  if (_.isEmpty(\n    _.pick.apply(_, [propsToSerialize].concat(transformFunctions))\n    )\n  ) {\n    return propsToSerialize;\n  } else {\n    const serializedProps = _.clone(propsToSerialize);\n\n    serializedProps[TRANSFORM_TOKEN] = transformNames.reduce(\n      (combinedProperties, transformFunction) => {\n      if (_.has(serializedProps, transformFunction)) {\n        combinedProperties +=\n          ` ${transformFunction}(${serializedProps[transformFunction]})`;\n\n        delete serializedProps[transformFunction];\n      }\n\n      return combinedProperties;\n    }, '').slice(1);\n\n    return serializedProps;\n  }\n};\n\n/*!\n * @param {Actor} actor\n * @param {string=} targetProp\n * @return {string}\n */\nexport const serializeActorStep = (actor, targetProp = undefined) =>\n  _.reduce(\n    combineTranfromProperties(\n      targetProp ? { [targetProp]: actor.get()[targetProp] } : actor.get(),\n      actor._transformOrder\n    ),\n    (serializedProps, val, key) =>\n      `${serializedProps}${key === 'transform' ? TRANSFORM_TOKEN : key}:${val};`,\n    '{') + '}';\n\n/*!\n * @param {Actor} actor\n * @param {number} increments\n * @param {number} incrementSize\n * @param {number} actorStart\n * @param {number} fromPercent\n * @param {KeyframeProperty=} fromProp\n * @return {Array.<string>}\n */\nexport const generateActorTrackSegment = (\n  actor,\n  increments,\n  incrementSize,\n  actorStart,\n  fromPercent,\n  fromProp = undefined\n) => {\n\n  const accumulator = [];\n  const length = actor.getLength();\n\n  for (let i = 0; i < increments; i++) {\n    const percent = fromPercent + (i * incrementSize);\n\n    actor._updateState(\n      ((percent / 100) * length) + actorStart,\n      true\n    );\n\n    const step = serializeActorStep(actor, fromProp && fromProp.name);\n\n    accumulator.push(`  ${+percent.toFixed(2)}% ${step}`);\n  }\n\n  return accumulator;\n};\n\n/*!\n * @param {Actor} actor\n * @param {number} steps\n * @return {string}\n */\nconst generateCombinedActorKeyframes = (actor, steps) =>\n  generateActorTrackSegment(actor, steps + 1, 100 / steps, 0, 0).join('\\n');\n\n/*!\n * @param {Actor} actor\n * @param {string} track\n * @param {number} actorStart\n * @return {string|undefined}\n */\nexport const simulateLeadingWait = (actor, track, actorStart) => {\n  const firstProp = actor._propertyTracks[track][0];\n\n  if (firstProp !== undefined && firstProp.millisecond !== actorStart) {\n    return generateActorTrackSegment(\n      actor,\n      1,\n      1,\n      firstProp.millisecond,\n      0,\n      firstProp\n    ).join('\\n');\n  }\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} track\n * @param {number} actorStart\n * @param {number} actorEnd\n * @return {string|undefined}\n */\nexport const simulateTrailingWait = (actor, track, actorStart, actorEnd) => {\n  const lastProp = _.last(actor._propertyTracks[track]);\n\n  if (lastProp !== undefined && lastProp.millisecond !== actorEnd) {\n    return generateActorTrackSegment(\n      actor,\n      1,\n      1,\n      actorStart,\n      100,\n      lastProp\n    ).join('\\n');\n  }\n};\n\n/*!\n * @param {KeyframeProperty} property\n * @param {number} actorStart\n * @param {number} actorLength\n * @return {number}\n */\nconst calculateStepPercent = (property, actorStart, actorLength) =>\n  ((property.millisecond - actorStart) / actorLength) * 100;\n\n/*!\n * @param {Actor} actor\n * @param {number} actorStart\n * @param {KeyframeProperty} fromProp\n * @param {KeyframeProperty} toProp\n * @param {number} fromPercent\n * @param {number} toPercent\n * @return {Array.<string>}\n */\nconst generateActorTrackWaitSegment = (\n  actor,\n  actorStart,\n  fromProp,\n  toProp,\n  fromPercent,\n  toPercent\n) =>\n  generateActorTrackSegment(\n    actor,\n    1,\n    toPercent - fromPercent,\n    actorStart,\n    fromPercent,\n    fromProp\n  );\n\n/*!\n * @param {KeyframeProperty} property\n * @param {KeyframeProperty} nextProperty\n * @return {boolean}\n */\nconst isSegmentAWait = (property, nextProperty) =>\n  property.name === nextProperty.name &&\n    property.value === nextProperty.value;\n\n/*!\n * @param {KeyframeProperty} property\n * @return {boolean}\n */\nexport const canOptimizeKeyframeProperty = property =>\n  !property.nextProperty ?\n    false :\n    isSegmentAWait(property, property.nextProperty) ?\n      true :\n      property.nextProperty.easing.split(' ').every((easing, i, easings) =>\n        !(!BEZIERS[easing] || (i > 0 && easings[i - 1] !== easing))\n      );\n\n/*!\n * @param {Actor} actor\n * @param {number} steps\n * @param {string} track\n * @return {string}\n */\nexport const generateActorKeyframes = (actor, steps, track) => {\n  // This function is completely crazy.  Simplify it?\n  const accumulator = [];\n  const end = actor.getEnd();\n  const start = actor.getStart();\n  const length = actor.getLength();\n  const leadingWait = simulateLeadingWait(actor, track, start);\n\n  if (leadingWait) {\n    accumulator.push(leadingWait);\n  }\n\n  let previousSegmentWasOptimized = false;\n  actor._propertyTracks[track].forEach(prop => {\n    const fromPercent = calculateStepPercent(prop, start, length);\n    const { nextProperty } = prop;\n\n    let toPercent, increments, incrementSize;\n\n    if (nextProperty) {\n      toPercent = calculateStepPercent(nextProperty, start, length);\n      const delta = toPercent - fromPercent;\n      increments = Math.floor((delta / 100) * steps) || 1;\n      incrementSize = delta / increments;\n    } else {\n      toPercent = 100;\n      increments = 1;\n      incrementSize = 1;\n    }\n\n    let trackSegment;\n    if (nextProperty && isSegmentAWait(prop, nextProperty)) {\n      trackSegment = generateActorTrackWaitSegment(\n        actor,\n        start,\n        prop,\n        nextProperty,\n        fromPercent,\n        toPercent\n      );\n\n      if (previousSegmentWasOptimized) {\n        trackSegment.shift();\n      }\n\n      previousSegmentWasOptimized = false;\n\n    } else if (canOptimizeKeyframeProperty(prop)) {\n      trackSegment = generateOptimizedKeyframeSegment(\n        prop,\n        fromPercent,\n        toPercent\n      );\n\n      // If this and the previous segment are optimized, remove the\n      // destination keyframe of the previous step.  The starting keyframe of\n      // the newest segment makes it redundant.\n      if (previousSegmentWasOptimized) {\n        accumulator[accumulator.length - 1] =\n          accumulator[accumulator.length - 1].split('\\n')[0];\n      }\n\n      previousSegmentWasOptimized = true;\n    } else {\n      trackSegment = generateActorTrackSegment(\n        actor,\n        increments,\n        incrementSize,\n        start,\n        fromPercent,\n        prop\n      );\n\n      if (previousSegmentWasOptimized) {\n        trackSegment.shift();\n      }\n\n      if (trackSegment.length) {\n        trackSegment = trackSegment.join('\\n');\n      }\n\n      previousSegmentWasOptimized = false;\n    }\n\n    if (trackSegment.length) {\n      accumulator.push(trackSegment);\n    }\n  });\n\n  const trailingWait = simulateTrailingWait(actor, track, start, end);\n\n  if (trailingWait) {\n    accumulator.push(trailingWait);\n  }\n\n  return accumulator.join('\\n');\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {number} steps\n * @param {boolean} doCombineProperties\n * @param {Array.<string>=} vendors\n * @return {string}\n */\nexport const generateBoilerplatedKeyframes = (\n  actor,\n  animName,\n  steps,\n  doCombineProperties,\n  vendors = undefined\n) =>\n\n  doCombineProperties ?\n    applyVendorBoilerplates(\n      generateCombinedActorKeyframes(actor, steps),\n      animName,\n      vendors\n    ) :\n    actor.getTrackNames().map(trackName =>\n      applyVendorBoilerplates(\n        generateActorKeyframes(actor, steps, trackName),\n        `${animName}-${trackName}`,\n        vendors\n      )\n    ).join('\\n');\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {string} prefix\n * @param {boolean} doCombineProperties\n * @return {string}\n */\nexport const generateAnimationNameProperty = (\n  actor,\n  animationName,\n  prefix,\n  doCombineProperties\n) => {\n\n  let renderedName = `  ${prefix}animation-name:`;\n\n  if (doCombineProperties) {\n    renderedName += ` ${animationName}-keyframes;`;\n  } else {\n    const trackNames = actor.getTrackNames();\n\n    const trackNamesToPrint = _.intersection(trackNames, transformFunctions).length ?\n      _.difference(trackNames, transformFunctions).concat('transform') :\n      trackNames;\n\n    renderedName = trackNamesToPrint.reduce(\n      (renderedName, trackName) =>\n        `${renderedName} ${animationName}-${trackName}-keyframes,`,\n      renderedName\n    ).replace(/.$/, ';');\n  }\n\n  return renderedName;\n};\n\n/*!\n * @param {Rekapi} rekapi\n * @param {string} prefix\n * @param {number|string=} iterations\n * @return {string}\n */\nexport const generateAnimationIterationProperty = (\n  rekapi,\n  prefix,\n  iterations = undefined\n) =>\n  `  ${prefix}animation-iteration-count: ${iterations !== undefined ?\n    iterations :\n    rekapi._timesToIterate === -1 ?\n      'infinite' :\n      rekapi._timesToIterate\n   };`;\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {string} vendor\n * @param {boolean} doCombineProperties\n * @param {number|string=} iterations\n * @param {boolean=} isCentered\n * @return {string}\n */\nexport const generateCSSAnimationProperties = (\n  actor,\n  animName,\n  vendor,\n  doCombineProperties,\n  iterations = undefined,\n  isCentered = false\n) => {\n  const prefix = VENDOR_PREFIXES[vendor];\n  const start = actor.getStart();\n  const end = actor.getEnd();\n\n  const generatedProperties = [\n    generateAnimationNameProperty(actor, animName, prefix, doCombineProperties),\n    `  ${prefix}animation-duration: ${end - start}ms;`,\n    `  ${prefix}animation-delay: ${start}ms;`,\n    `  ${prefix}animation-fill-mode: forwards;`,\n    `  ${prefix}animation-timing-function: linear;`,\n    generateAnimationIterationProperty(actor.rekapi, prefix, iterations),\n  ];\n\n  if (isCentered) {\n    generatedProperties.push(`  ${prefix}transform-origin: 0 0;`);\n  }\n\n  return generatedProperties.join('\\n');\n};\n\n/*!\n * @param {Actor} actor\n * @param {string} animName\n * @param {boolean} doCombineProperties\n * @param {Array.<string>=} vendors\n * @param {number|string=} iterations\n * @param {boolean=} isCentered\n * @return {string}\n */\nexport const generateCSSClass = (\n    actor,\n    animName,\n    doCombineProperties,\n    vendors = ['w3'],\n    iterations = undefined,\n    isCentered = undefined\n  ) =>\n\n  `.${animName} {\n${  vendors.map(vendor =>\n      generateCSSAnimationProperties(\n        actor,\n        animName,\n        vendor,\n        doCombineProperties,\n        iterations,\n        isCentered\n      )\n    ).join('\\n')}\n}`;\n\n/*!\n * @param {Actor} actor\n * @return {boolean}\n */\nexport const canOptimizeAnyKeyframeProperties = (actor) =>\n  _.any(\n    actor._keyframeProperties,\n    canOptimizeKeyframeProperty\n  ) &&\n  !_.intersection(\n    Object.keys(actor._propertyTracks),\n    transformFunctions\n  ).length;\n\n/*!\n * Creates the CSS `@keyframes` for an individual actor.\n * @param {Actor} actor\n * @param {Object=} options Same as options for Rekapi.prototype.toCSS.\n * @return {string}\n */\nexport const getActorCSS = (actor, options = {}) => {\n  const { name, vendors, iterations, isCentered } = options;\n\n  const animName = name ?\n    (actor.rekapi.getActorCount() > 1 ?\n      `${name}-${actor.id}` :\n      name\n    ) :\n    getActorClassName(actor);\n\n  const steps = Math.ceil(\n    (actor.rekapi.getAnimationLength() / 1000) * (options.fps || DEFAULT_FPS)\n  );\n\n  const doCombineProperties = !canOptimizeAnyKeyframeProperties(actor);\n\n  return [\n    generateCSSClass(\n      actor,\n      animName,\n      doCombineProperties,\n      vendors,\n      iterations,\n      isCentered\n    ),\n    generateBoilerplatedKeyframes(\n      actor,\n      animName,\n      steps,\n      doCombineProperties,\n      vendors\n    )\n  ].join('\\n');\n};\n\n/**\n * {@link rekapi.DOMRenderer} allows you to animate DOM elements.  This is\n * achieved either by [CSS `@keyframe`\n * animations](https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes), or\n * by per-frame inline style updates — keyframes are defined with the same API\n * in either case.  To render animations with the DOM, just supply any DOM\n * element to the {@link rekapi.Rekapi} constructor.  You may use\n * `document.body`, since it is generally always available:\n *\n *     const rekapi = new Rekapi(document.body);\n *\n *  To use this renderer's API, get a reference to the initialized object:\n *\n *     const domRenderer = rekapi.getRendererInstance(DOMRenderer);\n *\n * There are separate APIs for playing inline style animations and CSS\n * `@keyframe` animations.  For a detailed breakdown of how to choose between\n * these two APIs and use {@link rekapi.DOMRenderer} effectively, check out the\n * {@tutorial dom-rendering-in-depth} tutorial.\n *\n * __Note__: {@link rekapi.DOMRenderer} is added to {@link\n * rekapi.Rekapi#renderers} automatically, there is no reason to call the\n * constructor yourself in most cases.\n * @param {rekapi.Rekapi} rekapi The {@link rekapi.Rekapi} instance to render for.\n * @constructor rekapi.DOMRenderer\n * @extends {rekapi.renderer}\n */\nexport class DOMRenderer {\n  constructor (rekapi) {\n\n    Object.assign(this, {\n      rekapi,\n\n      // @private {number}\n      _playTimestamp: null,\n\n      // @private {string}\n      _cachedCSS: null,\n\n      // The HTMLStyleElement that gets injected into the DOM.\n      // @private {HTMLStyleElement)\n      _styleElement: null,\n\n      // @private {number}\n      _stopSetTimeoutHandle: null\n    });\n\n    rekapi.on('timelineModified', () => this._cachedCSS = null);\n    rekapi.on('addActor', onAddActor);\n  }\n\n  /**\n   * @method rekapi.DOMRenderer#canAnimateWithCSS\n   * @return {boolean} Whether or not the browser supports CSS `@keyframe`\n   * animations.\n   */\n  canAnimateWithCSS () {\n    return !!vendorPrefix;\n  }\n\n  /**\n   * Play the Rekapi animation as a CSS `@keyframe` animation.\n   *\n   * Note that this is not the same as {@link rekapi.Rekapi#play}.  That method\n   * controls inline style animations, while this method controls CSS\n   * `@keyframe` animations.\n   * @method rekapi.DOMRenderer#play\n   * @param {number} [iterations] How many times the animation should loop.\n   * This can be `null` or `0` if you want to loop the animation endlessly but\n   * also specify a value for `fps`.\n   * @param {number} [fps] How many `@keyframes` to generate per second of the\n   * animation.  A higher value results in a more precise CSS animation, but it\n   * will take longer to generate.  The default value is `30`.  You should not\n   * need to go higher than `60`.\n   */\n  play (iterations = undefined, fps = undefined) {\n    if (this.isPlaying()) {\n      this.stop();\n    }\n\n    this._styleElement = injectStyle(\n      this.rekapi,\n      this._cachedCSS || this.prerender.apply(this, arguments)\n    );\n\n    this._playTimestamp = now();\n\n    if (iterations) {\n      const animationLength = (iterations * this.rekapi.getAnimationLength());\n      this._stopSetTimeoutHandle = setTimeout(\n        this.stop.bind(this, true),\n        animationLength + INJECTED_STYLE_REMOVAL_BUFFER_MS\n      );\n    }\n\n    fireEvent(this.rekapi, 'play');\n  }\n\n  /**\n   * Stop a CSS `@keyframe` animation.  This also removes any `<style>`\n   * elements that were dynamically injected into the DOM.\n   *\n   * Note that this is not the same as {@link rekapi.Rekapi#stop}.  That method\n   * controls inline style animations, while this method controls CSS\n   * `@keyframe` animations.\n   * @method rekapi.DOMRenderer#stop\n   * @param {boolean=} goToEnd If true, skip to the end of the animation.  If\n   * false or omitted, set inline styles on the {@link rekapi.Actor} elements\n   * to keep them in their current position.\n   */\n  stop (goToEnd = undefined) {\n    if (this.isPlaying()) {\n      clearTimeout(this._stopSetTimeoutHandle);\n\n      // Forces a style update in WebKit/Presto\n      this._styleElement.innerHTML = '';\n\n      document.head.removeChild(this._styleElement);\n      this._styleElement = null;\n      const animationLength = this.rekapi.getAnimationLength();\n\n      this.rekapi.update(\n        goToEnd ?\n          animationLength :\n          (now() - this._playTimestamp) % animationLength\n      );\n\n      fireEvent(this.rekapi, 'stop');\n    }\n  }\n\n  /**\n   * @method rekapi.DOMRenderer#isPlaying\n   * @return {boolean} Whether or not a CSS `@keyframe` animation is running.\n   */\n  isPlaying () {\n    return !!this._styleElement;\n  }\n\n  /**\n   * Prerender and cache the CSS animation so that it is immediately ready to\n   * be used when it is needed in the future.  The function signature is\n   * identical to {@link rekapi.DOMRenderer#play}.  This\n   * is necessary to play a CSS animation and will be automatically called for\n   * you if you don't call it manually, but calling it ahead of time (such as\n   * on page load) will prevent any perceived lag when a CSS `@keyframe`\n   * animation is started.  The prerendered animation is cached for reuse until\n   * the timeline or a keyframe is modified.\n   *\n   * @method rekapi.DOMRenderer#prerender\n   * @param {number=} iterations How many times the animation should loop.\n   * This can be `null` or `0` if you want to loop the animation endlessly but\n   * also specify a value for `fps`.\n   * @param {number=} fps How many `@keyframes` to generate per second of\n   * the animation.  A higher value results in a more precise CSS animation,\n   * but it will take longer to generate.  The default value is `30`.  You\n   * should not need to go higher than `60`.\n   * @return {string} The prerendered CSS string.  You likely won't need this,\n   * as it is also cached internally.\n   */\n  prerender (iterations = undefined, fps = undefined) {\n    return this._cachedCSS = this.getCss({\n      vendors: [vendorPrefix],\n      fps,\n      iterations\n    });\n  }\n\n  /**\n   * You can decouple transform components in order to animate each property\n   * with its own easing curve:\n   *\n   *     actor\n   *       .keyframe(0, {\n   *         translateX: '0px',\n   *         translateY: '0px',\n   *         rotate: '0deg'\n   *       })\n   *       .keyframe(1500, {\n   *         translateX: '200px',\n   *         translateY: '200px',\n   *         rotate: '90deg'\n   *       }, {\n   *         translateX: 'easeOutExpo',\n   *         translateY: 'easeInSine',\n   *         rotate: 'elastic'\n   *       });\n   *\n   * CSS transform string components are order-dependent, but JavaScript object\n   * properties have an unpredictable order.  Rekapi must combine transform\n   * properties supplied to {@link rekapi.Actor#keyframe} (as shown above) into\n   * a single string when it renders each frame.  This method lets you change\n   * that order from the default.\n   *\n   * However, if you prefer a more standards-oriented approach, Rekapi also\n   * supports combining the transform components yourself, obviating the need\n   * for {@link rekapi.DOMRenderer#setActorTransformOrder} entirely:\n   *\n   *     actor\n   *       .keyframe(0, {\n   *         transform: 'translateX(0px) translateY(0px) rotate(0deg)'\n   *       })\n   *       .keyframe(1500, {\n   *         transform: 'translateX(200px) translateY(200px) rotate(90deg)'\n   *       }, {\n   *         transform: 'easeOutExpo easeInSine elastic'\n   *       });\n   * @method rekapi.DOMRenderer#setActorTransformOrder\n   * @param {rekapi.Actor} actor The {@link rekapi.Actor} to apply the new\n   * transform order to.\n   * @param {Array.<string>} orderedTransforms The array of transform names.\n   * The supported array values (and default order) are:\n   *\n   * - `translateX`\n   * - `translateY`\n   * - `translateZ`\n   * - `scale`\n   * - `scaleX`\n   * - `scaleY`\n   * - `perspective`\n   * - `rotate`\n   * - `rotateX`\n   * - `rotateY`\n   * - `rotateZ`\n   * - `skewX`\n   * - `skewY`\n   * @return {rekapi.Rekapi}\n   */\n  setActorTransformOrder (actor, orderedTransforms) {\n    const unrecognizedTransforms = _.reject(orderedTransforms, isTransformFunction);\n\n    if (unrecognizedTransforms.length) {\n      throw `Unknown or unsupported transform functions: ${unrecognizedTransforms.join(', ')}`;\n    }\n\n    // Ignore duplicate transform function names in the array\n    actor._transformOrder = _.uniq(orderedTransforms);\n\n    return this.rekapi;\n  }\n\n  /**\n   * Convert the animation to CSS `@keyframes`.\n   * @method rekapi.DOMRenderer#getCss\n   * @param {Object} [options={}]\n   * @param {Array.<string>} [options.vendors=['w3']] The browser vendors you\n   * want to support. Valid values are:\n   *   * `'microsoft'`\n   *   * `'mozilla'`\n   *   * `'opera'`\n   *   * `'w3'`\n   *   * `'webkit'`\n   *\n   *\n   * @param {number} [options.fps=30]  Defines the number of CSS `@keyframe` frames\n   * rendered per second of an animation.  CSS `@keyframes` are comprised of a\n   * series of explicitly defined steps, and more steps will allow for a more\n   * complex animation.  More steps will also result in a larger CSS string,\n   * and more time needed to generate the string.\n   * @param {string} [options.name] Define a custom name for your animation.\n   * This becomes the class name targeted by the generated CSS.\n   * @param {boolean} [options.isCentered] If `true`, the generated CSS will\n   * contain `transform-origin: 0 0;`, which centers the DOM element along the\n   * path of motion.  If `false` or omitted, no `transform-origin` rule is\n   * specified and the element is aligned to the path of motion by its top-left\n   * corner.\n   * @param {number} [options.iterations] How many times the generated\n   * animation should repeat.  If omitted, the animation will loop\n   * indefinitely.\n   * @return {string}\n   */\n  getCss (options = {}) {\n    const animationCSS = [];\n\n    _.each(this.rekapi.getAllActors(), actor => {\n      if (actor.context.nodeType === 1) {\n        animationCSS.push(getActorCSS(actor, options));\n      }\n    });\n\n    return animationCSS.join('\\n');\n  }\n}\n\n/*!\n * @param {Rekapi} rekapi\n */\nrendererBootstrappers.push(rekapi =>\n  // Node.nodeType 1 is an ELEMENT_NODE.\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType\n  rekapi.context.nodeType === 1 && new DOMRenderer(rekapi)\n);\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderers/dom.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n// WEBPACK FOOTER //\n// (webpack)/buildin/global.js","/**\n * @namespace rekapi\n */\n\n/**\n * An Object that provides utilities for rendering a {@link rekapi.Actor}.\n * @typedef {Object} rekapi.renderer\n * @property {rekapi.render} render A function that renders a {@link\n * rekapi.Actor}.\n */\n\n/**\n * A function that is called when an event is fired.  See {@link\n * rekapi.Rekapi#on} for a list of valid events.\n * @callback rekapi.eventHandler\n * @param {rekapi.Rekapi} rekapi A {@link rekapi.Rekapi} instance.\n * @param {Object} data Data provided from the event (see {@link\n * rekapi.Rekapi#on} for details).\n */\n\n/**\n * A function that gets called every time the actor's state is updated (once\n * every frame). This function should do something meaningful with the state of\n * the actor (for example, visually rendering to the screen).\n * @callback rekapi.render\n * @param {Object} context An actor's {@link rekapi.Actor#context} Object.\n * @param {Object} state An actor's current state properties.\n */\n\n/**\n * @callback rekapi.keyframeFunction\n * @param {rekapi.Actor} actor The {@link rekapi.Actor} to which this\n * {@link rekapi.keyframeFunction} was provided.\n * @param {number} drift A number that represents the delay between when the\n * function is called and when it was scheduled. There is typically some amount\n * of delay due to the nature of JavaScript timers.\n */\n\n/**\n * @callback rekapi.actorSortFunction\n * @param {rekapi.Actor} actor A {@link rekapi.Actor} that should expose a\n * `number` value to sort by.\n * @return {number}\n */\n\nexport { Rekapi } from './rekapi';\nexport { Actor } from './actor';\nexport { KeyframeProperty } from './keyframe-property';\nexport { CanvasRenderer } from './renderers/canvas';\nexport { DOMRenderer } from './renderers/dom';\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js"],"sourceRoot":""}